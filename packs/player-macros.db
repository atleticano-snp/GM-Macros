{"name":"Swap_token","type":"script","author":"Be8r6Sgxcs3sL08I","img":"modules/GMmacros/img/swap_token.png","scope":"global","command":"const tokens = canvas.tokens.controlled;\nif(tokens.length !== 2) return ui.notifications.warn('Please select exactly 2 tokens.');\n\nconst updates = [\n {_id: tokens[0].id, x: tokens[1].x, y: tokens[1].y},\n {_id: tokens[1].id, x: tokens[0].x, y: tokens[0].y}];\nawait canvas.scene.updateEmbeddedDocuments(\"Token\", updates);","flags":{"combat-utility-belt":{"macroTrigger":""},"advanced-macros":{"runAsGM":true,"runForEveryone":false,"runForSpecificUser":""},"macro-marker":{"activeData":{"icon":"icons/svg/dice-target.svg","tooltip":"New Macro","colour":"#ff0000","trigger":""}},"core":{"sourceId":"Macro.DmjzqVAL6mPck879"}},"ownership":{"default":0,"rbM5nB1AbUwbj4yJ":3,"Be8r6Sgxcs3sL08I":3},"_stats":{"systemId":"dnd5e","systemVersion":"2.0.3","coreVersion":"10.290","createdTime":1669768613214,"modifiedTime":1669768815403,"lastModifiedBy":"Be8r6Sgxcs3sL08I"},"folder":null,"sort":0,"_id":"0ZF5StyM0cBZL3D7"}
{"name":"Passar_turno","type":"script","author":"rbM5nB1AbUwbj4yJ","img":"modules/GMmacros/img/skip_turn.jpg","scope":"global","command":"/*\nAuthor: willisrocks\nDescription: \nEnds the current actors turn in a combat encounter. Useful when you don't pop out your combat tracker\nand want to end the turn from your hotbar.\nIf the user is a gamemaster, it will always end the current turn. For players, it will only end \nthe turn when the current actor in the turn order is owned by you. \nBased on the work of reddit user serrag97: https://www.reddit.com/r/FoundryVTT/comments/j1b8gs/next_turn_shortcut/\n*/\n\n// check if the user is a GM\nconst isGM = game.user.isGM;\n// check if the user owns the combatant whose turn it is\nconst isOwner = game.combat.combatant.isOwner;\n\nif (isGM || isOwner) {\n  game.combat.nextTurn();\n} else {\n  ui.notifications.info(\"As a player you can only advance your turn\");\n}","folder":null,"sort":0,"flags":{"combat-utility-belt":{"macroTrigger":""},"advanced-macros":{"runAsGM":false},"exportSource":{"world":"criador","system":"dnd5e","coreVersion":"0.8.8","systemVersion":"1.3.6"},"core":{"sourceId":"Macro.Us9ANKoXgfEYWFxz"}},"_id":"ABLx0o1RtltjLEoY","ownership":{"default":0,"rbM5nB1AbUwbj4yJ":3},"_stats":{"systemId":"dnd5e","systemVersion":"2.0.3","coreVersion":"10.290","createdTime":null,"modifiedTime":1668380922328,"lastModifiedBy":"Be8r6Sgxcs3sL08I"}}
{"name":"Draw-Shape-Sequencer","type":"script","scope":"global","author":"Be8r6Sgxcs3sL08I","img":"icons/svg/dice-target.svg","command":"new Sequence()\n    .effect()\n        .attachTo(token)\n        .persist()\n        .shape(\"circle\", {\n            lineSize: 4,\n            lineColor: \"#FF0000\",\n            radius: 1.5,\n            gridUnits: true,\n            name: \"test\"\n        })\n        .loopProperty(\"shapes.test\", \"scale.x\", { from: 0.9, to: 1.1, duration: 1000, pingPong: true, ease: \"easeInOutSine\" })\n        .loopProperty(\"shapes.test\", \"scale.y\", { from: 0.9, to: 1.1, duration: 1000, pingPong: true, ease: \"easeInOutSine\" })\n    .play()","ownership":{"default":0,"Be8r6Sgxcs3sL08I":3},"flags":{"advanced-macros":{"runAsGM":false,"runForEveryone":false,"runForSpecificUser":""},"core":{"sourceId":"Macro.Yxb15uAZuZaxgvSA"}},"_stats":{"systemId":"dnd5e","systemVersion":"2.0.3","coreVersion":"10.290","createdTime":1669826240566,"modifiedTime":1669826277536,"lastModifiedBy":"Be8r6Sgxcs3sL08I"},"folder":null,"sort":0,"_id":"GNYMzgXHEmnAAX5l"}
{"name":"Emissary_of_Redemption_2","type":"script","scope":"global","author":"Be8r6Sgxcs3sL08I","img":"icons/svg/dice-target.svg","command":"const version = \"10.0.33\"\nconst workfloww = MidiQOL.Workflow.getWorkflow(args[0].uuid)\nconst owner = workfloww.actor;\nif (!owner?.effects.find(i=>i.data.label === \"Emissary of Redemption Attacked\")) return;\n\nif (args[0].macroPass = \"isDamaged\") {\ntry {\n\tconst actor = args[0].options?.actor;\n\tconst token = args[0].options?.token;\n\tconst target = fromUuidSync(args[0].tokenUuid);\n\tconst workflow = args[0];\n\tlet danocausado = workflow.damageTotal;\n\tlet damageType = workflow.damageDetail\n\tconst reflete = Math.floor(danocausado+1) // arredonda para cima, pq a resistencia vai ser para baixo.\n\tconst damageRoll = await new Roll(`${reflete}`).roll({async: true});\n\tawait new MidiQOL.DamageOnlyWorkflow(actor, token, damageRoll.total, damageType, [token], damageRoll, {flavor: \"Vc causou dano em mim! Corre√ß√£o de dano aqui\",itemCardId: args[0].itemCardId});\n } catch (err) {\n   console.error(`Retribution ${version}`, err);\n }\n}","ownership":{"default":0,"Be8r6Sgxcs3sL08I":3},"flags":{"advanced-macros":{"runAsGM":true,"runForSpecificUser":""},"core":{"sourceId":"Macro.T16Rs86D08UNZUnF"}},"_stats":{"systemId":"dnd5e","systemVersion":"2.1.5","coreVersion":"10.291","createdTime":1686611738114,"modifiedTime":1686614084969,"lastModifiedBy":"Be8r6Sgxcs3sL08I"},"folder":null,"sort":0,"_id":"IBl7ceAFV9bbijZe"}
{"name":"Activate effect suspended","type":"script","scope":"global","author":"Be8r6Sgxcs3sL08I","img":"icons/svg/dice-target.svg","command":"const effect = actor.effects.find(e => e.data.label === \"Emissary of Redemption\");\nif(!effect.disabled) {\n    await effect.update({ disabled: true });\n} else {\nawait effect.update({ disabled: false });}","ownership":{"default":0,"Be8r6Sgxcs3sL08I":3},"flags":{"advanced-macros":{"runAsGM":false,"runForEveryone":false,"runForSpecificUser":""},"core":{"sourceId":"Macro.WgvsACwCs4kf6xZO"}},"_stats":{"systemId":"dnd5e","systemVersion":"2.0.3","coreVersion":"10.290","createdTime":1670004676757,"modifiedTime":1670007927726,"lastModifiedBy":"Be8r6Sgxcs3sL08I"},"folder":null,"sort":0,"_id":"SEjSi6K7SP7HRE4C"}
{"name":"Acoes_extras","type":"script","author":"Be8r6Sgxcs3sL08I","img":"modules/GMmacros/img/acoes_adicionais.png","scope":"global","command":"// pag 274\n\nnew Dialog({\n        title: \"Op√ß√µes de a√ß√µes extras\",\n        content: \"<p>Selecione a a√ß√£o</p>\",\n        buttons: {\n            one: {\n                label: ` <img class=\"button-image\" src=\"modules/dfreds-convenient-effects/images/grappled.svg\", style=\"width: 40px; height: 40px\">Agarrar (Grapple)`,\n                callback: async () => {\n(async()=>{\n\n//inicio code\nconst attacker = token; //selected token\nconst target = game.user.targets.first(); //targeted creature\nconst uuid = game.user.targets.first().actor.uuid;\nconst hasEffectApplied = game.dfreds.effectInterface.hasEffectApplied('Grappled', uuid);\nconst immunity = target.actor.system.traits.ci.value.has(\"grappled\");\n\nif(immunity === true) {\n  ui.notifications.info(\"Immune to Grapple!\");\n  return;\n}\n\nconst skilltoberolled = target.actor.system.skills.ath.total < target.actor.system.skills.acr.total ? \"acr\" : \"ath\";\n\nresults = await game.MonksTokenBar.requestContestedRoll({\n    token:attacker,\n    request: 'skill:ath'\n},{\n    token: target,\n    request:`skill:${skilltoberolled}`\n},{\n    silent:true, \n    fastForward:false,\n    flavor: `${attacker.name} tries to grapple ${target.name}.`, \n});\n\nlet i=0;\nwhile (results.flags['monks-tokenbar'][`token${attacker.id}`].passed === \"waiting\" && i < 30) {\n    await new Promise(resolve => setTimeout(resolve, 500))\n    i++;\n}\nif (results.flags[\"monks-tokenbar\"][`token${attacker.id}`].passed === \"won\") {\n    success = \"Agarrou com Sucesso: \";\n    let the_message = `${attacker.name} <span style=\"color: blue\"><b> ${success}</b> </span> ${target.name}.`;\n    ChatMessage.create({\n    user: game.user._id,\n    speaker: ChatMessage.getSpeaker({actor: attacker}),\n    content: the_message,\n});\nif (!hasEffectApplied) {\n    await game.dfreds.effectInterface.addEffect({ effectName: 'Grappled', uuid});\n }\n} else {\n    success = \"Falhou o Agarr√£o em\";\n    let the_message = `${attacker.name} <span style=\"color: red\"><b> ${success}</b> </span> ${target.name}.`;\n    ChatMessage.create({\n    user: game.user._id,\n    speaker: ChatMessage.getSpeaker({actor: attacker}),\n    content: the_message,\n});\n} // fim code\n\n})();\n\n                       } // fim async content\n                 }, // fim agarrar\n            nine: {\n                label: ` <img class=\"button-image\" src=\"modules/dfreds-convenient-effects/images/prone.svg\", style=\"width: 40px; height: 40px\">Derrubar (Shove) (Prone)` ,\n                callback: async () => {\n(async()=>{\n\n//inicio code\nconst attacker = token; //selected token\nconst target = game.user.targets.first(); //targeted creature\nconst uuid = game.user.targets.first().actor.uuid;\nconst hasEffectApplied = game.dfreds.effectInterface.hasEffectApplied('Prone', uuid);\nconst immunity = target.actor.system.traits.ci.value.has(\"prone\");\n\nif(immunity === true) {\n  ui.notifications.info(\"Immune to Prone!\");\n  return;\n}\n\nconst skilltoberolled = target.actor.system.skills.ath.total < target.actor.system.skills.acr.total ? \"acr\" : \"ath\";\n\nresults = await game.MonksTokenBar.requestContestedRoll({\n    token:attacker,\n    request: 'skill:ath'\n},{\n    token: target,\n    request:`skill:${skilltoberolled}`\n},{\n    silent:true, \n    fastForward:false,\n    flavor: `${attacker.name} tenta derrubar Prone: ${target.name}.`, \n});\n\nlet i=0;\nwhile (results.flags['monks-tokenbar'][`token${attacker.id}`].passed === \"waiting\" && i < 30) {\n    await new Promise(resolve => setTimeout(resolve, 500))\n    i++;\n}\nif (results.flags[\"monks-tokenbar\"][`token${attacker.id}`].passed === \"won\") {\n    success = \"Derrubou com Sucesso: \";\n    let the_message = `${attacker.name} <span style=\"color: blue\"><b> ${success}</b> </span> ${target.name}.`;\n    ChatMessage.create({\n    user: game.user._id,\n    speaker: ChatMessage.getSpeaker({actor: attacker}),\n    content: the_message,\n});\nif (!hasEffectApplied) {\n    await game.dfreds.effectInterface.addEffect({ effectName: 'Prone', uuid});\n }\n} else {\n    success = \"Falhou em Derrubar\";\n    let the_message = `${attacker.name} <span style=\"color: red\"><b> ${success}</b> </span> ${target.name}.`;\n    ChatMessage.create({\n    user: game.user._id,\n    speaker: ChatMessage.getSpeaker({actor: attacker}),\n    content: the_message,\n});\n} // fim code\n\n\n})();\n\n                       } // fim async content\n                 }, // fim empurr√£o prone\n\n            seven: {\n                label: \" ü§ú Empurar 5ft (Shove)\",\n                callback: async () => {\n(async()=>{\n\n\n//inicio code\nconst attacker = token; //selected token\nconst target = game.user.targets.first(); //targeted creature\nconst uuid = game.user.targets.first().actor.uuid;\n\nconst skilltoberolled = target.actor.system.skills.ath.total < target.actor.system.skills.acr.total ? \"acr\" : \"ath\";\n\nresults = await game.MonksTokenBar.requestContestedRoll({\n    token:attacker,\n    request: 'skill:ath'\n},{\n    token: target,\n    request:`skill:${skilltoberolled}`\n},{\n    silent:true, \n    fastForward:false,\n    flavor: `${attacker.name} tenta empurrar 5ft: ${target.name}.`, \n});\n\nlet i=0;\nwhile (results.flags['monks-tokenbar'][`token${attacker.id}`].passed === \"waiting\" && i < 30) {\n    await new Promise(resolve => setTimeout(resolve, 500))\n    i++;\n}\nif (results.flags[\"monks-tokenbar\"][`token${attacker.id}`].passed === \"won\") {\n    success = \"empurrou com Sucesso: \";\n    let the_message = `${attacker.name} <span style=\"color: blue\"><b> ${success}</b> </span> ${target.name}. Mova o token.`;\n    ChatMessage.create({\n    user: game.user._id,\n    speaker: ChatMessage.getSpeaker({actor: attacker}),\n    content: the_message,\n});\n} else {\n    success = \"Falhou em empurrar\";\n    let the_message = `${attacker.name} <span style=\"color: red\"><b> ${success}</b> </span> ${target.name}.`;\n    ChatMessage.create({\n    user: game.user._id,\n    speaker: ChatMessage.getSpeaker({actor: attacker}),\n    content: the_message,\n});\n} // fim code\n\n\n})();\n\n                       } // fim async content\n                 }, // fim empurr√£o\n\n            six: {\n                label: \"üõ°Ô∏è Esquiva (Dodge)\",\n                callback: async () => {\nconst uuid = canvas.tokens.controlled[0].actor.uuid;\nconst hasEffectApplied = await game.dfreds.effectInterface.hasEffectApplied('Dodge', uuid);\n\nif (!hasEffectApplied) {\n  game.dfreds.effectInterface.addEffect({ effectName: 'Dodge', uuid });\n} else {\n  game.dfreds.effectInterface.removeEffect({ effectName: 'Dodge', uuid });}\n                       } \n            }, // fim dodge\n            two: {\n                label: \"‚öîÔ∏è Desarmar (limitado)\",\n                callback: async () => {\n(async()=>{\n\nChatMessage.create({content: \"Uma criatura pode usar um ataque com arma para derrubar uma arma ou outro objeto das m√£os de um alvo. O atacante faz uma jogada de ataque contestada pelo teste de For√ßa (Atletismo) ou Destreza (Acrobacia) do alvo. Se o atacante vencer a disputa, o ataque n√£o causa dano ou qualquer outro efeito negativo, mas o atacado deixa o objeto cair no ch√£o. O atacante tem desvantagem em sua jogada de ataque se o alvo estiver segurando o objeto com duas ou mais m√£os. O alvo tem vantagem em seu teste de atributo se for maior que a criatura atacante, ou desvantagem se for menor\"});\n\n(async()=>{/**\n * Grab a list of tools in the selected player's inventory, then all the user to make a roll on the tool.\n * Will take into consideration if the player is proficient in using the tool.\n */\n\n// get the first entry from the array of currently selected tokens. Works best/exclusively with one selected token\nconst target = canvas.tokens.controlled[0].actor;\n// get the abilities of the selected token for ease of access later\nconst { abilities } = target.data.data;\n// Only items set as \"tools\" will be included!\n// get all held and equipped Tools/Kits/Supplies. Might want to replace with /[tT]ools|[kK]it|[sS]upplies|[sS]et$/ if gaming sets should be included\nlet toolsInInventory = target.items.filter(i=>i.type === \"weapon\");\n// const toolProficiencies = target.data.data.traits.toolProf; // Tools have proficiency mod in the object under <item>.data.data.proficient. \nlet tool = undefined;\n\n// Choose ability mod dialog\nconst abilityDialog = (async () => {\n    let template = `\n    <div>\n        <div class=\"form-group\">\n            <label>Choose ability</label>\n            <select id=\"selectedAbility\">`\n    for (let ability in abilities) {\n        switch (ability) {\n            case \"str\":\n                abilities[ability].name = \"Strength\"\n                break;\n            case \"dex\":\n                abilities[ability].name = \"Dexterity\"\n                break;\n            case \"con\":\n                abilities[ability].name = \"Constitution\"\n                break;\n            case \"int\":\n                abilities[ability].name = \"Intelligence\"\n                break;\n            case \"wis\":\n                abilities[ability].name = \"Wisdom\"\n                break;\n            case \"cha\":\n                abilities[ability].name = \"Charisma\"\n                break;\n            default:\n                console.log(\"something went wrong\");\n        }\n        template += `<option value=\"${ability}\">${abilities[ability].name} (${abilities[ability].value})</option>`;\n    }\n    template += `</select>\n        </div>\n    </div>`\n\n\n    new Dialog({\n        title: tool.name,\n        content: template,\n        buttons: {\n            ok: {\n                icon: '<i class=\"fas fa-check\"></i>',\n                label: \"OK\",\n                callback: async (html) => {\n                    const selection = html.find(\"#selectedAbility\")[0].value;\n                    console.log(tool, target);\n                    let prof = tool.data.data.proficient * target.data.data.attributes.prof; // target might be half or doubly proficient. This will make sure it is accounted for\n                    let bonusattack = tool.data.data.attackBonus\n\t\t    let typeac = tool.data.data.actionType\n\t\t    const globalbonus = tool.data.data.actionType == \"mwak\" ? target.data.data.bonuses.mwak.attack : target.data.data.bonuses.rwak.attack\n                    let messageContent = `${target.name} Rolou Dado 1: <b>[[1d20+${abilities[selection].mod}+${prof}+${bonusattack}+${globalbonus}]]</b> e Dado 2: <b>[[1d20+${abilities[selection].mod}+${prof}+${bonusattack}+${globalbonus}]]</b> para a a√ß√£o  de desarmar com ${tool.name}. Utilize dado 1 caso n√£o tenha vantagem nem desvantgem. [[1d20+${abilities[selection].mod}(${abilities[selection].name})+${prof}(Proficiency)+${bonusattack}(Bonus Arma)+${globalbonus}(Bonus global)]]</b><br>`;\n                    let chatData = {\n                        user: game.user.id,\n                        speaker: ChatMessage.getSpeaker(),\n                        content: messageContent,\n                        // uncomment the line below to always whisper the roll to the GM\n                        // whisper: game.users.entities.filter(u => u.isGM).map(u => u._id)\n                    };\n                    ChatMessage.create(chatData, {});\n               }\n            },\n            cancel: {\n                icon: '<i class=\"fas fa-times\"></i>',\n                label: 'Cancel'\n            }\n        },\n        default: \"cancel\"\n    }).render(true);\n})\n\n// Choose tool dialog\nif (toolsInInventory.length) {\n    (async () => {\n        let template = `\n        <div>\n            <div class=\"form-group\">\n                <label>Choose a tool</label>\n                <select id=\"selectedTool\">`\n        toolsInInventory.forEach( tempTool => {    \n            template += `<option value=\"${tempTool.name}\">${tempTool.name}</option>`;\n        });\n        template += `</select>\n            </div>\n        </div>`;\n\n        new Dialog({\n            title: 'Which tool?',\n            content: template,\n            buttons: {\n                ok: {\n                    icon: '<i class=\"fas fa-check\"></i>',\n                    label: \"OK\",\n                    callback: async (html) => {\n                        let selection = html.find(\"#selectedTool\")[0].value;\n                        tool = toolsInInventory.find( item => item.name === selection )\n                        abilityDialog();\n                   }\n                },\n                cancel: {\n                    icon: '<i class=\"fas fa-times\"></i>',\n                    label: 'Cancel'\n                }\n            },\n            default: \"cancel\"\n        }).render(true);\n    })()    \n}\n\nelse {\t\n    new Dialog({\n        title: 'No Tools!',\n        content: '<p>You don\\'t seem to have any tool with you.</p>',\n        buttons: {\n            ok: {\n                icon: '<i class=\"fas fa-check\"></i>',\n                label: \"OK\"\n            }\n        },\n        default: \"ok\"\n    }).render(true);\n}}) ()\n\n// check which has a better modifier\nconst attacker = token; //selected token\nconst target = game.user.targets.first(); //targeted creature\nconst uuid = game.user.targets.first().actor.uuid;\nconst skilltoberolled = target.actor.system.skills.ath.total < target.actor.system.skills.acr.total ? \"acr\" : \"ath\";\nconst targets = Array.from(game.user.targets);\nawait game.MonksTokenBar.requestRoll(targets,{request:`skill:${ skilltoberolled}`, silent: true});\n\n\n})()\n                 } }, // two\n            four: {\n                label: \"Escalar (Climb)\",\n                callback: async () => {\n(async()=>{\n\n\n//inicio code\nconst attacker = token; //selected token\nconst skilltoberolled = attacker.actor.system.skills.ath.total < attacker.actor.system.skills.acr.total ? \"acr\" : \"ath\";\nconst target = game.user.targets.first(); //targeted creature\nconst uuid = game.user.targets.first().actor.uuid;\nresults = await game.MonksTokenBar.requestContestedRoll({\n    token:attacker,\n    request:`skill:${skilltoberolled}`\n},{\n    token: target,\n    request: 'skill:acr'\n},{\n    silent:true, \n    fastForward:false,\n    flavor: `${attacker.name} tenta escalar ${target.name}.`, \n});\n\nlet i=0;\nwhile (results.flags['monks-tokenbar'][`token${attacker.id}`].passed === \"waiting\" && i < 30) {\n    await new Promise(resolve => setTimeout(resolve, 500))\n    i++;\n}\nif (results.flags[\"monks-tokenbar\"][`token${attacker.id}`].passed === \"won\") {\n    success = \"Escalou com Sucesso: \";\n    let the_message = `${attacker.name} <span style=\"color: blue\"><b> ${success}</b> </span> ${target.name}.`;\n    ChatMessage.create({\n    user: game.user._id,\n    speaker: ChatMessage.getSpeaker({actor: attacker}),\n    content: the_message,\n});\n} else {\n    success = \"Falhou em Escalar\";\n    let the_message = `${attacker.name} <span style=\"color: red\"><b> ${success}</b> </span> ${target.name}.`;\n    ChatMessage.create({\n    user: game.user._id,\n    speaker: ChatMessage.getSpeaker({actor: attacker}),\n    content: the_message,\n});\n} // fim code\n\n})();\n                       }\n                 }, ////// fim escalar\n            three: {\n                label: \"Atropelar (Overrun)\",\n                callback: async () => {\n(async()=>{\n\n\n//inicio code\nconst attacker = token; //selected token\nconst target = game.user.targets.first(); //targeted creature\n\nresults = await game.MonksTokenBar.requestContestedRoll({\n    token:attacker,\n    request: 'skill:ath'\n},{\n    token: target,\n    request: 'skill:ath'\n},{\n    silent:true, \n    fastForward:false,\n    flavor: `${attacker.name} tenta passar pelo espa√ßo de ${target.name}.`, \n});\n\nlet i=0;\nwhile (results.flags['monks-tokenbar'][`token${attacker.id}`].passed === \"waiting\" && i < 30) {\n    await new Promise(resolve => setTimeout(resolve, 500))\n    i++;\n}\nif (results.flags[\"monks-tokenbar\"][`token${attacker.id}`].passed === \"won\") {\n    success = \"Atropelou com Sucesso: \";\n    let the_message = `${attacker.name} <span style=\"color: blue\"><b> ${success}</b> </span> ${target.name}. Voc√™ pode passar 1 vez pelo espa√ßo do alvo.`;\n    ChatMessage.create({\n    user: game.user._id,\n    speaker: ChatMessage.getSpeaker({actor: attacker}),\n    content: the_message,\n});\n} else {\n    success = \"Falhou em Escalar\";\n    let the_message = `${attacker.name} <span style=\"color: red\"><b> ${success}</b> </span> ${target.name}.`;\n    ChatMessage.create({\n    user: game.user._id,\n    speaker: ChatMessage.getSpeaker({actor: attacker}),\n    content: the_message,\n});\n} // fim code\n\n})();\n                       } \n            }, // fim atropelar\n\n            five: {\n                label: \"Cambalhota (Tumble)\",\n                callback: async () => {\n(async()=>{\n\n\n//inicio code\nconst attacker = token; //selected token\nconst target = game.user.targets.first(); //targeted creature\n\nresults = await game.MonksTokenBar.requestContestedRoll({\n    token:attacker,\n    request: 'skill:acr'\n},{\n    token: target,\n    request: 'skill:acr'\n},{\n    silent:true, \n    fastForward:false,\n    flavor: `${attacker.name} tenta passar pelo espa√ßo de ${target.name}.`, \n});\n\nlet i=0;\nwhile (results.flags['monks-tokenbar'][`token${attacker.id}`].passed === \"waiting\" && i < 30) {\n    await new Promise(resolve => setTimeout(resolve, 500))\n    i++;\n}\nif (results.flags[\"monks-tokenbar\"][`token${attacker.id}`].passed === \"won\") {\n    success = \"Passou com Sucesso por: \";\n    let the_message = `${attacker.name} <span style=\"color: blue\"><b> ${success}</b> </span> ${target.name}. Voc√™ pode passar 1 vez pelo espa√ßo do alvo.`;\n    ChatMessage.create({\n    user: game.user._id,\n    speaker: ChatMessage.getSpeaker({actor: attacker}),\n    content: the_message,\n});\n} else {\n    success = \"Falhou em Passar por:\";\n    let the_message = `${attacker.name} <span style=\"color: red\"><b> ${success}</b> </span> ${target.name}.`;\n    ChatMessage.create({\n    user: game.user._id,\n    speaker: ChatMessage.getSpeaker({actor: attacker}),\n    content: the_message,\n});\n} // fim code\n\n\n\n})();\n                       } \n            }, // fim cambalhota\n\n           eight: {\n                label: \"Escapar agarr√£o (Grapple)\",\n                callback: async () => {\n(async()=>{\n\n//inicio code\nconst attacker = token; //selected token\nconst target = game.user.targets.first(); //targeted creature\nconst uuid = game.user.targets.first().actor.uuid;\nconst meuuid = canvas.tokens.controlled[0].actor.uuid;\nconst skilltoberolled = attacker.actor.system.skills.ath.total < attacker.actor.system.skills.acr.total ? \"acr\" : \"ath\";\n\nresults = await game.MonksTokenBar.requestContestedRoll({\n    token:attacker,\n    request:`skill:${skilltoberolled}`\n},{\n    token: target,\n    request: 'skill:ath'\n},{\n    silent:true, \n    fastForward:false,\n    flavor: `${attacker.name} tenta escapar do agarr√£o de ${target.name}.`, \n});\n\nlet i=0;\nwhile (results.flags['monks-tokenbar'][`token${attacker.id}`].passed === \"waiting\" && i < 30) {\n    await new Promise(resolve => setTimeout(resolve, 500))\n    i++;\n}\nif (results.flags[\"monks-tokenbar\"][`token${attacker.id}`].passed === \"won\") {\n\n    let targetEffect = actor.effects.find(eff => eff.label === 'Grappled');\n    MidiQOL.socket().executeAsGM(\"removeEffects\", {'actorUuid': meuuid, effects: [targetEffect.id]});\n\n    //await game.dfreds.effectInterface.removeEffect({ effectName: 'Grappled', meuuid});\n    success = \"Escapou com Sucesso: \";\n    let the_message = `${attacker.name} <span style=\"color: blue\"><b> ${success}</b> </span> ${target.name}.`;\n    ChatMessage.create({\n    user: game.user._id,\n    speaker: ChatMessage.getSpeaker({actor: attacker}),\n    content: the_message,\n});\n} else {\n    success = \"Falhou em escapar do agarr√£o de\";\n    let the_message = `${attacker.name} <span style=\"color: red\"><b> ${success}</b> </span> ${target.name}.`;\n    ChatMessage.create({\n    user: game.user._id,\n    speaker: ChatMessage.getSpeaker({actor: attacker}),\n    content: the_message,\n});\n} // fim code\n\n\n})();\n\n                       } // fim async content\n                 }, // fim escapar\n\n\n} }).render(true);//fim fun√ß√£o","flags":{"combat-utility-belt":{"macroTrigger":""},"advanced-macros":{"runAsGM":false,"runForSpecificUser":""},"exportSource":{"world":"criador","system":"dnd5e","coreVersion":"0.8.8","systemVersion":"1.3.6"},"macro-marker":{"activeData":{"icon":"modules/GMmacros/img/acoes_adicionais.png","tooltip":"A√ß√µes_extras"}},"core":{"sourceId":"Macro.biIFauGQz2Xs9pkZ"}},"ownership":{"default":3,"QwT9izJ4aW8QVTjo":3,"Be8r6Sgxcs3sL08I":3},"_stats":{"systemId":"dnd5e","systemVersion":"2.2.1","coreVersion":"10.291","createdTime":1668381000745,"modifiedTime":1688584457646,"lastModifiedBy":"Be8r6Sgxcs3sL08I"},"folder":null,"sort":0,"_id":"VNX79QsUqZyxAJhQ"}
{"name":"Emissary_of_Redemption_1","type":"script","scope":"global","author":"Be8r6Sgxcs3sL08I","img":"icons/svg/dice-target.svg","command":"const workflow = MidiQOL.Workflow.getWorkflow(args[0].uuid); \nif (args[0].hitTargetUuids.length === 0) return {}\nconst tactor = (Array.from(workflow.targets))[0]?.actor; \nif (tactor?.effects.find(i=>i.data.label === \"Emissary of Redemption Attacked\")) {return} else {\n\tlet bsEffect = new ActiveEffect({label: \"Emissary of Redemption Attacked\", \n\t\t\t\t icon: \"modules/GMmacros/img/Emissary_redemption.png\"});\n\tfor (let tokenUuid of args[0].hitTargetUuids) {\n        \tconst target = await fromUuid(tokenUuid);\n        \tconst targetActor = target.actor;\n       \t\tif (!targetActor) continue;\n\t\tawait MidiQOL.socket().executeAsGM(\"createEffects\", {actorUuid: targetActor.uuid, effects: [bsEffect.toObject()]})\n }\n}","ownership":{"default":0,"Be8r6Sgxcs3sL08I":3},"flags":{"advanced-macros":{"runAsGM":true,"runForSpecificUser":""},"core":{"sourceId":"Macro.HWPAGjNnWkvDoTi1"}},"_stats":{"systemId":"dnd5e","systemVersion":"2.1.5","coreVersion":"10.291","createdTime":1686595886014,"modifiedTime":1686614353920,"lastModifiedBy":"Be8r6Sgxcs3sL08I"},"folder":null,"sort":0,"_id":"VnLNDtVNgVsKuHS3"}
{"$$deleted":true,"_id":"VNX79QsUqZyxAJhQ"}
{"name":"Acoes_extras","type":"script","author":"Be8r6Sgxcs3sL08I","img":"modules/GMmacros/img/acoes_adicionais.png","scope":"global","command":"// pag 274 DMG\n\n\n\n\n\nnew Dialog({\n        title: \"Op√ß√µes de a√ß√µes extras // üéØ = marque um alvo\",\n        content: \"<p>Selecione a a√ß√£o - </p>\",\n        render:(html)=>{\n         $(html[2]).css({'flex-direction':'column'})\n         html[0].remove()\n        },\n        buttons: {\n\n            six: {\n                label: `<img class=\"button-image\" src=\"modules/dfreds-convenient-effects/images/dodging.svg\", style=\"width: 30px; height: 30px\">   Esquiva (Dodge) - Action`,\n                callback: async () => {\nconst uuid = canvas.tokens.controlled[0].actor.uuid;\nconst hasEffectApplied = await game.dfreds.effectInterface.hasEffectApplied('Dodge', uuid);\n\nif (!hasEffectApplied) {\n  game.dfreds.effectInterface.addEffect({ effectName: 'Dodge', uuid });\n} else {\n  game.dfreds.effectInterface.removeEffect({ effectName: 'Dodge', uuid });}\n                       } \n            }, // fim dodge\n\n            one: {\n                label: ` <img class=\"button-image\" src=\"modules/GMmacros/img/grappled.png\", style=\"width: 30px; height: 30px\">   Agarrar (Grapple) - Action üéØ`,\n                callback: async () => {\n(async()=>{\n\n//inicio code\nconst attacker = token; //selected token\nconst target = game.user.targets.first(); //targeted creature\nconst uuid = game.user.targets.first().actor.uuid;\nconst hasEffectApplied = game.dfreds.effectInterface.hasEffectApplied('Grappled', uuid);\nconst immunity = target.actor.system.traits.ci.value.has(\"grappled\");\n\nif(immunity === true) {\n  ui.notifications.info(\"Immune to Grapple!\");\n  return;\n}\n\nconst skilltoberolled = target.actor.system.skills.ath.total < target.actor.system.skills.acr.total ? \"acr\" : \"ath\";\n\nresults = await game.MonksTokenBar.requestContestedRoll({\n    token:attacker,\n    request: 'skill:ath'\n},{\n    token: target,\n    request:`skill:${skilltoberolled}`\n},{\n    silent:true, \n    fastForward:false,\n    flavor: `${attacker.name} tries to grapple ${target.name}.`, \n});\n\nlet i=0;\nwhile (results.flags['monks-tokenbar'][`token${attacker.id}`].passed === \"waiting\" && i < 30) {\n    await new Promise(resolve => setTimeout(resolve, 900))\n    i++;\n}\nif (results.flags[\"monks-tokenbar\"][`token${attacker.id}`].passed === \"won\") {\n    success = \"Agarrou com Sucesso: \";\n    let the_message = `${attacker.name} <span style=\"color: blue\"><b> ${success}</b> </span> ${target.name}.`;\n    ChatMessage.create({\n    user: game.user._id,\n    speaker: ChatMessage.getSpeaker({actor: attacker}),\n    content: the_message,\n});\nif (!hasEffectApplied) {\n    await game.dfreds.effectInterface.addEffect({ effectName: 'Grappled', uuid});\n }\n} else {\n    success = \"Falhou o Agarr√£o em\";\n    let the_message = `${attacker.name} <span style=\"color: red\"><b> ${success}</b> </span> ${target.name}.`;\n    ChatMessage.create({\n    user: game.user._id,\n    speaker: ChatMessage.getSpeaker({actor: attacker}),\n    content: the_message,\n});\n} // fim code\n\n})();\n\n                       } // fim async content\n                 }, // fim agarrar\n\n           eight: {\n                label: `<img class=\"button-image\" src=\"icons/svg/padlock.svg\", style=\"width: 30px; height: 30px\">   Escapar agarr√£o (Grapple) - Action üéØ`,\n                callback: async () => {\n(async()=>{\n\n//inicio code\nconst attacker = token; //selected token\nconst target = game.user.targets.first(); //targeted creature\nconst uuid = game.user.targets.first().actor.uuid;\nconst meuuid = canvas.tokens.controlled[0].actor.uuid;\nconst skilltoberolled = attacker.actor.system.skills.ath.total < attacker.actor.system.skills.acr.total ? \"acr\" : \"ath\";\n\nresults = await game.MonksTokenBar.requestContestedRoll({\n    token:attacker,\n    request:`skill:${skilltoberolled}`\n},{\n    token: target,\n    request: 'skill:ath'\n},{\n    silent:true, \n    fastForward:false,\n    flavor: `${attacker.name} tenta escapar do agarr√£o de ${target.name}.`, \n});\n\nlet i=0;\nwhile (results.flags['monks-tokenbar'][`token${attacker.id}`].passed === \"waiting\" && i < 30) {\n    await new Promise(resolve => setTimeout(resolve, 900))\n    i++;\n}\nif (results.flags[\"monks-tokenbar\"][`token${attacker.id}`].passed === \"won\") {\n\n    let targetEffect = actor.effects.find(eff => eff.label === 'Grappled');\n    MidiQOL.socket().executeAsGM(\"removeEffects\", {'actorUuid': meuuid, effects: [targetEffect.id]});\n\n    //await game.dfreds.effectInterface.removeEffect({ effectName: 'Grappled', meuuid});\n    success = \"Escapou com Sucesso: \";\n    let the_message = `${attacker.name} <span style=\"color: blue\"><b> ${success}</b> </span> ${target.name}.`;\n    ChatMessage.create({\n    user: game.user._id,\n    speaker: ChatMessage.getSpeaker({actor: attacker}),\n    content: the_message,\n});\n} else {\n    success = \"Falhou em escapar do agarr√£o de\";\n    let the_message = `${attacker.name} <span style=\"color: red\"><b> ${success}</b> </span> ${target.name}.`;\n    ChatMessage.create({\n    user: game.user._id,\n    speaker: ChatMessage.getSpeaker({actor: attacker}),\n    content: the_message,\n});\n} // fim code\n\n\n})();\n\n                       } // fim async content\n                 }, // fim escapar\n\n            nine: {\n                label: ` <img class=\"button-image\" src=\"modules/dfreds-convenient-effects/images/prone.svg\", style=\"width: 30px; height: 30px\">   Derrubar (Shove) (Prone) - Action üéØ` ,\n                callback: async () => {\n(async()=>{\n\n//inicio code\nconst attacker = token; //selected token\nconst target = game.user.targets.first(); //targeted creature\nconst uuid = game.user.targets.first().actor.uuid;\nconst hasEffectApplied = game.dfreds.effectInterface.hasEffectApplied('Prone', uuid);\nconst immunity = target.actor.system.traits.ci.value.has(\"prone\");\n\nif(immunity === true) {\n  ui.notifications.info(\"Immune to Prone!\");\n  return;\n}\n\nconst skilltoberolled = target.actor.system.skills.ath.total < target.actor.system.skills.acr.total ? \"acr\" : \"ath\";\n\nresults = await game.MonksTokenBar.requestContestedRoll({\n    token:attacker,\n    request: 'skill:ath'\n},{\n    token: target,\n    request:`skill:${skilltoberolled}`\n},{\n    silent:true, \n    fastForward:false,\n    flavor: `${attacker.name} tenta derrubar Prone: ${target.name}.`, \n});\n\nlet i=0;\nwhile (results.flags['monks-tokenbar'][`token${attacker.id}`].passed === \"waiting\" && i < 30) {\n    await new Promise(resolve => setTimeout(resolve, 900))\n    i++;\n}\nif (results.flags[\"monks-tokenbar\"][`token${attacker.id}`].passed === \"won\") {\n    success = \"Derrubou com Sucesso: \";\n    let the_message = `${attacker.name} <span style=\"color: blue\"><b> ${success}</b> </span> ${target.name}.`;\n    ChatMessage.create({\n    user: game.user._id,\n    speaker: ChatMessage.getSpeaker({actor: attacker}),\n    content: the_message,\n});\nif (!hasEffectApplied) {\n    await game.dfreds.effectInterface.addEffect({ effectName: 'Prone', uuid});\n }\n} else {\n    success = \"Falhou em Derrubar\";\n    let the_message = `${attacker.name} <span style=\"color: red\"><b> ${success}</b> </span> ${target.name}.`;\n    ChatMessage.create({\n    user: game.user._id,\n    speaker: ChatMessage.getSpeaker({actor: attacker}),\n    content: the_message,\n});\n} // fim code\n\n\n})();\n\n                       } // fim async content\n                 }, // fim empurr√£o prone\n\n            seven: {\n                label: \" ü§ú Empurar 5ft (Shove) - Action üéØ\",\n                callback: async () => {\n(async()=>{\n\n\n//inicio code\nconst attacker = token; //selected token\nconst target = game.user.targets.first(); //targeted creature\nconst uuid = game.user.targets.first().actor.uuid;\n\nconst skilltoberolled = target.actor.system.skills.ath.total < target.actor.system.skills.acr.total ? \"acr\" : \"ath\";\n\nresults = await game.MonksTokenBar.requestContestedRoll({\n    token:attacker,\n    request: 'skill:ath'\n},{\n    token: target,\n    request:`skill:${skilltoberolled}`\n},{\n    silent:true, \n    fastForward:false,\n    flavor: `${attacker.name} tenta empurrar 5ft: ${target.name}.`, \n});\n\nlet i=0;\nwhile (results.flags['monks-tokenbar'][`token${attacker.id}`].passed === \"waiting\" && i < 30) {\n    await new Promise(resolve => setTimeout(resolve, 900))\n    i++;\n}\nif (results.flags[\"monks-tokenbar\"][`token${attacker.id}`].passed === \"won\") {\n    success = \"empurrou com Sucesso: \";\n    let the_message = `${attacker.name} <span style=\"color: blue\"><b> ${success}</b> </span> ${target.name}. Mova o token.`;\n    ChatMessage.create({\n    user: game.user._id,\n    speaker: ChatMessage.getSpeaker({actor: attacker}),\n    content: the_message,\n});\n} else {\n    success = \"Falhou em empurrar\";\n    let the_message = `${attacker.name} <span style=\"color: red\"><b> ${success}</b> </span> ${target.name}.`;\n    ChatMessage.create({\n    user: game.user._id,\n    speaker: ChatMessage.getSpeaker({actor: attacker}),\n    content: the_message,\n});\n} // fim code\n\n\n})();\n\n                       } // fim async content\n                 }, // fim empurr√£o\n\n\n\n\n\n\n\n            four: {\n                label: \"Escalar (Climb) - Action üéØ\",\n                callback: async () => {\n(async()=>{\n\n\n//inicio code\nconst attacker = token; //selected token\nconst skilltoberolled = attacker.actor.system.skills.ath.total < attacker.actor.system.skills.acr.total ? \"acr\" : \"ath\";\nconst target = game.user.targets.first(); //targeted creature\nconst uuid = game.user.targets.first().actor.uuid;\nresults = await game.MonksTokenBar.requestContestedRoll({\n    token:attacker,\n    request:`skill:${skilltoberolled}`\n},{\n    token: target,\n    request: 'skill:acr'\n},{\n    silent:true, \n    fastForward:false,\n    flavor: `${attacker.name} tenta escalar ${target.name}.`, \n});\n\nlet i=0;\nwhile (results.flags['monks-tokenbar'][`token${attacker.id}`].passed === \"waiting\" && i < 30) {\n    await new Promise(resolve => setTimeout(resolve, 900))\n    i++;\n}\nif (results.flags[\"monks-tokenbar\"][`token${attacker.id}`].passed === \"won\") {\n    success = \"Escalou com Sucesso: \";\n    let the_message = `${attacker.name} <span style=\"color: blue\"><b> ${success}</b> </span> ${target.name}.`;\n    ChatMessage.create({\n    user: game.user._id,\n    speaker: ChatMessage.getSpeaker({actor: attacker}),\n    content: the_message,\n});\n} else {\n    success = \"Falhou em Escalar\";\n    let the_message = `${attacker.name} <span style=\"color: red\"><b> ${success}</b> </span> ${target.name}.`;\n    ChatMessage.create({\n    user: game.user._id,\n    speaker: ChatMessage.getSpeaker({actor: attacker}),\n    content: the_message,\n});\n} // fim code\n\n})();\n                       }\n                 }, ////// fim escalar\n            three: {\n                label: \"Atropelar (Overrun) - Action or Bonus action  üéØ\",\n                callback: async () => {\n(async()=>{\n\n\n//inicio code\nconst attacker = token; //selected token\nconst target = game.user.targets.first(); //targeted creature\n\nresults = await game.MonksTokenBar.requestContestedRoll({\n    token:attacker,\n    request: 'skill:ath'\n},{\n    token: target,\n    request: 'skill:ath'\n},{\n    silent:true, \n    fastForward:false,\n    flavor: `${attacker.name} tenta passar pelo espa√ßo de ${target.name}.`, \n});\n\nlet i=0;\nwhile (results.flags['monks-tokenbar'][`token${attacker.id}`].passed === \"waiting\" && i < 30) {\n    await new Promise(resolve => setTimeout(resolve, 900))\n    i++;\n}\nif (results.flags[\"monks-tokenbar\"][`token${attacker.id}`].passed === \"won\") {\n    success = \"Atropelou com Sucesso: \";\n    let the_message = `${attacker.name} <span style=\"color: blue\"><b> ${success}</b> </span> ${target.name}. Voc√™ pode passar 1 vez pelo espa√ßo do alvo.`;\n    ChatMessage.create({\n    user: game.user._id,\n    speaker: ChatMessage.getSpeaker({actor: attacker}),\n    content: the_message,\n});\n} else {\n    success = \"Falhou em Escalar\";\n    let the_message = `${attacker.name} <span style=\"color: red\"><b> ${success}</b> </span> ${target.name}.`;\n    ChatMessage.create({\n    user: game.user._id,\n    speaker: ChatMessage.getSpeaker({actor: attacker}),\n    content: the_message,\n});\n} // fim code\n\n})();\n                       } \n            }, // fim atropelar\n\n\n            five: {\n                label: \"Cambalhota (Tumble) - Action or Bonus action üéØ\",\n                callback: async () => {\n(async()=>{\n\n\n//inicio code\nconst attacker = token; //selected token\nconst target = game.user.targets.first(); //targeted creature\n\nresults = await game.MonksTokenBar.requestContestedRoll({\n    token:attacker,\n    request: 'skill:acr'\n},{\n    token: target,\n    request: 'skill:acr'\n},{\n    silent:true, \n    fastForward:false,\n    flavor: `${attacker.name} tenta passar pelo espa√ßo de ${target.name}.`, \n});\n\nlet i=0;\nwhile (results.flags['monks-tokenbar'][`token${attacker.id}`].passed === \"waiting\" && i < 30) {\n    await new Promise(resolve => setTimeout(resolve, 900))\n    i++;\n}\nif (results.flags[\"monks-tokenbar\"][`token${attacker.id}`].passed === \"won\") {\n    success = \"Passou com Sucesso por: \";\n    let the_message = `${attacker.name} <span style=\"color: blue\"><b> ${success}</b> </span> ${target.name}. Voc√™ pode passar 1 vez pelo espa√ßo do alvo.`;\n    ChatMessage.create({\n    user: game.user._id,\n    speaker: ChatMessage.getSpeaker({actor: attacker}),\n    content: the_message,\n});\n} else {\n    success = \"Falhou em Passar por:\";\n    let the_message = `${attacker.name} <span style=\"color: red\"><b> ${success}</b> </span> ${target.name}.`;\n    ChatMessage.create({\n    user: game.user._id,\n    speaker: ChatMessage.getSpeaker({actor: attacker}),\n    content: the_message,\n});\n} // fim code\n\n\n\n})();\n                       } \n            }, // fim cambalhota\n\n\n            two: {\n                label: \"‚öîÔ∏è Desarmar (limitado) - Action  üéØ\",\n                callback: async () => {\n(async()=>{\n\nChatMessage.create({content: \"Uma criatura pode usar um ataque com arma para derrubar uma arma ou outro objeto das m√£os de um alvo. O atacante faz uma jogada de ataque contestada pelo teste de For√ßa (Atletismo) ou Destreza (Acrobacia) do alvo. Se o atacante vencer a disputa, o ataque n√£o causa dano ou qualquer outro efeito negativo, mas o atacado deixa o objeto cair no ch√£o. O atacante tem desvantagem em sua jogada de ataque se o alvo estiver segurando o objeto com duas ou mais m√£os. O alvo tem vantagem em seu teste de atributo se for maior que a criatura atacante, ou desvantagem se for menor\"});\n\n(async()=>{/**\n * Grab a list of tools in the selected player's inventory, then all the user to make a roll on the tool.\n * Will take into consideration if the player is proficient in using the tool.\n */\n\n// get the first entry from the array of currently selected tokens. Works best/exclusively with one selected token\nconst target = canvas.tokens.controlled[0].actor;\n// get the abilities of the selected token for ease of access later\nconst { abilities } = target.data.data;\n// Only items set as \"tools\" will be included!\n// get all held and equipped Tools/Kits/Supplies. Might want to replace with /[tT]ools|[kK]it|[sS]upplies|[sS]et$/ if gaming sets should be included\nlet toolsInInventory = target.items.filter(i=>i.type === \"weapon\");\n// const toolProficiencies = target.data.data.traits.toolProf; // Tools have proficiency mod in the object under <item>.data.data.proficient. \nlet tool = undefined;\n\n// Choose ability mod dialog\nconst abilityDialog = (async () => {\n    let template = `\n    <div>\n        <div class=\"form-group\">\n            <label>Choose ability</label>\n            <select id=\"selectedAbility\">`\n    for (let ability in abilities) {\n        switch (ability) {\n            case \"str\":\n                abilities[ability].name = \"Strength\"\n                break;\n            case \"dex\":\n                abilities[ability].name = \"Dexterity\"\n                break;\n            case \"con\":\n                abilities[ability].name = \"Constitution\"\n                break;\n            case \"int\":\n                abilities[ability].name = \"Intelligence\"\n                break;\n            case \"wis\":\n                abilities[ability].name = \"Wisdom\"\n                break;\n            case \"cha\":\n                abilities[ability].name = \"Charisma\"\n                break;\n            default:\n                console.log(\"something went wrong\");\n        }\n        template += `<option value=\"${ability}\">${abilities[ability].name} (${abilities[ability].value})</option>`;\n    }\n    template += `</select>\n        </div>\n    </div>`\n\n\n    new Dialog({\n        title: tool.name,\n        content: template,\n        buttons: {\n            ok: {\n                icon: '<i class=\"fas fa-check\"></i>',\n                label: \"OK\",\n                callback: async (html) => {\n                    const selection = html.find(\"#selectedAbility\")[0].value;\n                    console.log(tool, target);\n                    let prof = tool.data.data.proficient * target.data.data.attributes.prof; // target might be half or doubly proficient. This will make sure it is accounted for\n                    let bonusattack = tool.data.data.attackBonus\n\t\t    let typeac = tool.data.data.actionType\n\t\t    const globalbonus = tool.data.data.actionType == \"mwak\" ? target.data.data.bonuses.mwak.attack : target.data.data.bonuses.rwak.attack\n                    let messageContent = `${target.name} Rolou Dado 1: <b>[[1d20+${abilities[selection].mod}+${prof}+${bonusattack}+${globalbonus}]]</b> e Dado 2: <b>[[1d20+${abilities[selection].mod}+${prof}+${bonusattack}+${globalbonus}]]</b> para a a√ß√£o  de desarmar com ${tool.name}. Utilize dado 1 caso n√£o tenha vantagem nem desvantgem. [[1d20+${abilities[selection].mod}(${abilities[selection].name})+${prof}(Proficiency)+${bonusattack}(Bonus Arma)+${globalbonus}(Bonus global)]]</b><br>`;\n                    let chatData = {\n                        user: game.user.id,\n                        speaker: ChatMessage.getSpeaker(),\n                        content: messageContent,\n                        // uncomment the line below to always whisper the roll to the GM\n                        // whisper: game.users.entities.filter(u => u.isGM).map(u => u._id)\n                    };\n                    ChatMessage.create(chatData, {});\n               }\n            },\n            cancel: {\n                icon: '<i class=\"fas fa-times\"></i>',\n                label: 'Cancel'\n            }\n        },\n        default: \"cancel\"\n    }).render(true);\n})\n\n// Choose tool dialog\nif (toolsInInventory.length) {\n    (async () => {\n        let template = `\n        <div>\n            <div class=\"form-group\">\n                <label>Choose a tool</label>\n                <select id=\"selectedTool\">`\n        toolsInInventory.forEach( tempTool => {    \n            template += `<option value=\"${tempTool.name}\">${tempTool.name}</option>`;\n        });\n        template += `</select>\n            </div>\n        </div>`;\n\n        new Dialog({\n            title: 'Which tool?',\n            content: template,\n            buttons: {\n                ok: {\n                    icon: '<i class=\"fas fa-check\"></i>',\n                    label: \"OK\",\n                    callback: async (html) => {\n                        let selection = html.find(\"#selectedTool\")[0].value;\n                        tool = toolsInInventory.find( item => item.name === selection )\n                        abilityDialog();\n                   }\n                },\n                cancel: {\n                    icon: '<i class=\"fas fa-times\"></i>',\n                    label: 'Cancel'\n                }\n            },\n            default: \"cancel\"\n        }).render(true);\n    })()    \n}\n\nelse {\t\n    new Dialog({\n        title: 'No Tools!',\n        content: '<p>You don\\'t seem to have any tool with you.</p>',\n        buttons: {\n            ok: {\n                icon: '<i class=\"fas fa-check\"></i>',\n                label: \"OK\"\n            }\n        },\n        default: \"ok\"\n    }).render(true);\n}}) ()\n\n// check which has a better modifier\nconst attacker = token; //selected token\nconst target = game.user.targets.first(); //targeted creature\nconst uuid = game.user.targets.first().actor.uuid;\nconst skilltoberolled = target.actor.system.skills.ath.total < target.actor.system.skills.acr.total ? \"acr\" : \"ath\";\nconst targets = Array.from(game.user.targets);\nawait game.MonksTokenBar.requestRoll(targets,{request:`skill:${ skilltoberolled}`, silent: true});\n\n\n})()\n                 } }, // two\n\n\n} }).render(true);//fim fun√ß√£o","flags":{"combat-utility-belt":{"macroTrigger":""},"advanced-macros":{"runAsGM":false,"runForSpecificUser":""},"exportSource":{"world":"criador","system":"dnd5e","coreVersion":"0.8.8","systemVersion":"1.3.6"},"macro-marker":{"activeData":{"icon":"modules/GMmacros/img/acoes_adicionais.png","tooltip":"A√ß√µes_extras"}},"core":{"sourceId":"Macro.biIFauGQz2Xs9pkZ"}},"ownership":{"default":3,"QwT9izJ4aW8QVTjo":3,"Be8r6Sgxcs3sL08I":3},"_stats":{"systemId":"dnd5e","systemVersion":"2.2.1","coreVersion":"10.291","createdTime":1668381000745,"modifiedTime":1688602052420,"lastModifiedBy":"Be8r6Sgxcs3sL08I"},"folder":null,"sort":0,"_id":"AOJprYmCqobIubHm"}
