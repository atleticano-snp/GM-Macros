{"name":"Swap_token","type":"script","author":"Be8r6Sgxcs3sL08I","img":"modules/GMmacros/img/swap_token.png","scope":"global","command":"const tokens = canvas.tokens.controlled;\nif(tokens.length !== 2) return ui.notifications.warn('Please select exactly 2 tokens.');\n\nconst updates = [\n {_id: tokens[0].id, x: tokens[1].x, y: tokens[1].y},\n {_id: tokens[1].id, x: tokens[0].x, y: tokens[0].y}];\nawait canvas.scene.updateEmbeddedDocuments(\"Token\", updates);","flags":{"combat-utility-belt":{"macroTrigger":""},"advanced-macros":{"runAsGM":true,"runForEveryone":false,"runForSpecificUser":""},"macro-marker":{"activeData":{"icon":"icons/svg/dice-target.svg","tooltip":"New Macro","colour":"#ff0000","trigger":""}},"core":{"sourceId":"Macro.DmjzqVAL6mPck879"}},"ownership":{"default":0,"rbM5nB1AbUwbj4yJ":3,"Be8r6Sgxcs3sL08I":3},"_stats":{"systemId":"dnd5e","systemVersion":"2.0.3","coreVersion":"10.290","createdTime":1669768613214,"modifiedTime":1669768815403,"lastModifiedBy":"Be8r6Sgxcs3sL08I"},"folder":null,"sort":0,"_id":"0ZF5StyM0cBZL3D7"}
{"name":"Passar_turno","type":"script","author":"rbM5nB1AbUwbj4yJ","img":"modules/GMmacros/img/skip_turn.jpg","scope":"global","command":"/*\nAuthor: willisrocks\nDescription: \nEnds the current actors turn in a combat encounter. Useful when you don't pop out your combat tracker\nand want to end the turn from your hotbar.\nIf the user is a gamemaster, it will always end the current turn. For players, it will only end \nthe turn when the current actor in the turn order is owned by you. \nBased on the work of reddit user serrag97: https://www.reddit.com/r/FoundryVTT/comments/j1b8gs/next_turn_shortcut/\n*/\n\n// check if the user is a GM\nconst isGM = game.user.isGM;\n// check if the user owns the combatant whose turn it is\nconst isOwner = game.combat.combatant.isOwner;\n\nif (isGM || isOwner) {\n  game.combat.nextTurn();\n} else {\n  ui.notifications.info(\"As a player you can only advance your turn\");\n}","folder":null,"sort":0,"flags":{"combat-utility-belt":{"macroTrigger":""},"advanced-macros":{"runAsGM":false},"exportSource":{"world":"criador","system":"dnd5e","coreVersion":"0.8.8","systemVersion":"1.3.6"},"core":{"sourceId":"Macro.Us9ANKoXgfEYWFxz"}},"_id":"ABLx0o1RtltjLEoY","ownership":{"default":0,"rbM5nB1AbUwbj4yJ":3},"_stats":{"systemId":"dnd5e","systemVersion":"2.0.3","coreVersion":"10.290","createdTime":null,"modifiedTime":1668380922328,"lastModifiedBy":"Be8r6Sgxcs3sL08I"}}
{"name":"Draw-Shape-Sequencer","type":"script","scope":"global","author":"Be8r6Sgxcs3sL08I","img":"icons/svg/dice-target.svg","command":"new Sequence()\n    .effect()\n        .attachTo(token)\n        .persist()\n        .shape(\"circle\", {\n            lineSize: 4,\n            lineColor: \"#FF0000\",\n            radius: 1.5,\n            gridUnits: true,\n            name: \"test\"\n        })\n        .loopProperty(\"shapes.test\", \"scale.x\", { from: 0.9, to: 1.1, duration: 1000, pingPong: true, ease: \"easeInOutSine\" })\n        .loopProperty(\"shapes.test\", \"scale.y\", { from: 0.9, to: 1.1, duration: 1000, pingPong: true, ease: \"easeInOutSine\" })\n    .play()","ownership":{"default":0,"Be8r6Sgxcs3sL08I":3},"flags":{"advanced-macros":{"runAsGM":false,"runForEveryone":false,"runForSpecificUser":""},"core":{"sourceId":"Macro.Yxb15uAZuZaxgvSA"}},"_stats":{"systemId":"dnd5e","systemVersion":"2.0.3","coreVersion":"10.290","createdTime":1669826240566,"modifiedTime":1669826277536,"lastModifiedBy":"Be8r6Sgxcs3sL08I"},"folder":null,"sort":0,"_id":"GNYMzgXHEmnAAX5l"}
{"name":"Emissary_of_Redemption_2","type":"script","scope":"global","author":"Be8r6Sgxcs3sL08I","img":"icons/svg/dice-target.svg","command":"const version = \"10.0.33\"\nconst workfloww = MidiQOL.Workflow.getWorkflow(args[0].uuid)\nconst owner = workfloww.actor;\nif (!owner?.effects.find(i=>i.data.label === \"Emissary of Redemption Attacked\")) return;\n\nif (args[0].macroPass = \"isDamaged\") {\ntry {\n\tconst actor = args[0].options?.actor;\n\tconst token = args[0].options?.token;\n\tconst target = fromUuidSync(args[0].tokenUuid);\n\tconst workflow = args[0];\n\tlet danocausado = workflow.damageTotal;\n\tlet damageType = workflow.damageDetail\n\tconst reflete = Math.floor(danocausado+1) // arredonda para cima, pq a resistencia vai ser para baixo.\n\tconst damageRoll = await new Roll(`${reflete}`).roll({async: true});\n\tawait new MidiQOL.DamageOnlyWorkflow(actor, token, damageRoll.total, damageType, [token], damageRoll, {flavor: \"Vc causou dano em mim! Correção de dano aqui\",itemCardId: args[0].itemCardId});\n } catch (err) {\n   console.error(`Retribution ${version}`, err);\n }\n}","ownership":{"default":0,"Be8r6Sgxcs3sL08I":3},"flags":{"advanced-macros":{"runAsGM":true,"runForSpecificUser":""},"core":{"sourceId":"Macro.T16Rs86D08UNZUnF"}},"_stats":{"systemId":"dnd5e","systemVersion":"2.1.5","coreVersion":"10.291","createdTime":1686611738114,"modifiedTime":1686614084969,"lastModifiedBy":"Be8r6Sgxcs3sL08I"},"folder":null,"sort":0,"_id":"IBl7ceAFV9bbijZe"}
{"name":"Acoes_extras","type":"script","author":"Be8r6Sgxcs3sL08I","img":"modules/GMmacros/img/acoes_adicionais.png","scope":"global","command":"// pag 274\n\nnew Dialog({\n        title: \"Opções de ações extras\",\n        content: \"<p>Select the effect</p>\",\n        buttons: {\n            one: {\n                label: \"Agarrar (Grapple)\",\n                callback: async () => {\n(async()=>{\n\n\nconst uuid = game.user.targets.first().actor.uuid;\nconst targets = Array.from(game.user.targets);\nlet me = canvas.tokens.controlled[0].actor;\nlet target = Array.from(game.user.targets)[0];\nconst hasEffectApplied = game.dfreds.effectInterface.hasEffectApplied('Grappled', uuid);\nconst immunity = target.actor.system.traits.ci.value.has(\"grappled\");\nif(immunity === true) {\n  ui.notifications.info(\"They are immune to Grapple!\");\n  return;\n}\n\nconst wait = async (ms) => new Promise((resolve)=> setTimeout(resolve, ms));\n// check which has a better modifier\nlet Cub_Condition = game.macros.getName(\"Cub_Condition\");\nlet athRoll = await me.rollSkill('ath');\nlet getAcr = target.actor.data.data.skills.acr.total;\nlet getAth = target.actor.data.data.skills.ath.total;\nlet bestSkill = getAcr > getAth ? \"acr\" : \"ath\";\n\nfor (const target of targets) {\nawait game.MonksTokenBar.requestRoll(targets,{request:`skill:${bestSkill}`, silent: true});\nawait wait(11000)\n\nconst listMessages = game.messages.contents\nconst lastMessage = listMessages[listMessages.length - 1];\nlet tokenid = 'token'+target.id;\nlet saveRoll = lastMessage.data.flags[\"monks-tokenbar\"][tokenid].total\nif (saveRoll < athRoll.total) {\nif (!hasEffectApplied) {\n  await game.dfreds.effectInterface.addEffect({ effectName: 'Grappled', uuid});\n  success = \"Agarrão com Sucesso\";\n  let the_message = `${me.name} <span style=\"color: blue\"><b> ${success}</b> </span> ${target.name}.`;\n    ChatMessage.create({\n    user: game.user._id,\n    speaker: ChatMessage.getSpeaker({actor: me}),\n    content: the_message,\n});\n  } }\n  }\n\n})();\n\n                       } // fim async content\n                 }, // fim agarrar\n            nine: {\n                label: \"Derrubar (Shove) (Prone)\",\n                callback: async () => {\n(async()=>{\n\nlet target = Array.from(game.user.targets)[0];\nconst uuid = game.user.targets.first().actor.uuid;\nconst targets = Array.from(game.user.targets);\nlet me = canvas.tokens.controlled[0].actor;\nconst hasEffectApplied = game.dfreds.effectInterface.hasEffectApplied('Prone', uuid);\nconst immunity = target.actor.system.traits.ci.value.has(\"prone\");\nif(immunity === true) {\n  ui.notifications.info(\"They are immune to Prone!\");\n  return;\n}\n\nconst wait = async (ms) => new Promise((resolve)=> setTimeout(resolve, ms));\n// check which has a better modifier\n\nlet athRoll = await me.rollSkill('ath');\nlet getAcr = target.actor.data.data.skills.acr.total;\nlet getAth = target.actor.data.data.skills.ath.total;\nlet bestSkill = getAcr > getAth ? \"acr\" : \"ath\";\n\nfor (const target of targets) {\nawait game.MonksTokenBar.requestRoll(targets,{request:`skill:${bestSkill}`, silent: true});\nawait wait(11000)\n\nconst listMessages = game.messages.contents\nconst lastMessage = listMessages[listMessages.length - 1];\nlet tokenid = 'token'+target.id;\nlet saveRoll = lastMessage.data.flags[\"monks-tokenbar\"][tokenid].total\nif (saveRoll < athRoll.total) {\nif (!hasEffectApplied) {\n  await game.dfreds.effectInterface.addEffect({ effectName: 'Prone', uuid});\n  success = \"Derrubar com Sucesso\";\n  let the_message = `${me.name} <span style=\"color: blue\"><b> ${success}</b> </span> ${target.name}.`;\n    ChatMessage.create({\n    user: game.user._id,\n    speaker: ChatMessage.getSpeaker({actor: me}),\n    content: the_message,\n});\n  } }\n  }\n\n\n})();\n\n                       } // fim async content\n                 }, // fim empurrão prone\n\n            seven: {\n                label: \"Empurar 5ft (Shove)\",\n                callback: async () => {\n(async()=>{\nlet Cub_Condition = game.macros.getName(\"Cub_Condition\");\nlet target = Array.from(game.user.targets)[0];\nlet me = canvas.tokens.controlled[0].actor;\nlet athRoll = await me.rollSkill('ath');\nlet getAcr = target.actor.data.data.skills.acr.total;\nlet getAth = target.actor.data.data.skills.ath.total;\nlet bestSkill = getAcr > getAth ? \"acr\" : \"ath\";\nlet skillRoll = await target.actor.rollSkill(bestSkill);\n\nlet success = \"\";\nif(athRoll.total > skillRoll.total) {\nsuccess = \"Empurrão com Sucesso\";\nlet the_message = `${me.name} <span style=\"color: blue\"><b> ${success}</b> </span> ${target.name}. A criatura é afastada 5 feet (1 quadrado) ou cai no chão (Prone)`;\nChatMessage.create({\n    user: game.user._id,\n    speaker: ChatMessage.getSpeaker({actor: me}),\n    content: the_message,\n});\n} else {\nsuccess = \"Falhou em Empurrar\";\nlet the_message = `${me.name} <span style=\"color: red\"><b> ${success}</b> </span> ${target.name}.`;\nChatMessage.create({\n    user: game.user._id,\n    speaker: ChatMessage.getSpeaker({actor: me}),\n    content: the_message,\n});\n}\n\n})();\n\n                       } // fim async content\n                 }, // fim empurrão\n\n            six: {\n                label: \"Esquiva (Dodge)\",\n                callback: async () => {\nconst uuid = canvas.tokens.controlled[0].actor.uuid;\nconst hasEffectApplied = await game.dfreds.effectInterface.hasEffectApplied('Dodge', uuid);\n\nif (!hasEffectApplied) {\n  game.dfreds.effectInterface.addEffect({ effectName: 'Dodge', uuid });\n} else {\n  game.dfreds.effectInterface.removeEffect({ effectName: 'Dodge', uuid });}\n                       } \n            }, // fim dodge\n            two: {\n                label: \"Desarmar\",\n                callback: async () => {\n(async()=>{\n(async()=>{/**\n * Grab a list of tools in the selected player's inventory, then all the user to make a roll on the tool.\n * Will take into consideration if the player is proficient in using the tool.\n */\n\n// get the first entry from the array of currently selected tokens. Works best/exclusively with one selected token\nconst target = canvas.tokens.controlled[0].actor;\n// get the abilities of the selected token for ease of access later\nconst { abilities } = target.data.data;\n// Only items set as \"tools\" will be included!\n// get all held and equipped Tools/Kits/Supplies. Might want to replace with /[tT]ools|[kK]it|[sS]upplies|[sS]et$/ if gaming sets should be included\nlet toolsInInventory = target.items.filter(i=>i.type === \"weapon\");\n// const toolProficiencies = target.data.data.traits.toolProf; // Tools have proficiency mod in the object under <item>.data.data.proficient. \nlet tool = undefined;\n\n// Choose ability mod dialog\nconst abilityDialog = (async () => {\n    let template = `\n    <div>\n        <div class=\"form-group\">\n            <label>Choose ability</label>\n            <select id=\"selectedAbility\">`\n    for (let ability in abilities) {\n        switch (ability) {\n            case \"str\":\n                abilities[ability].name = \"Strength\"\n                break;\n            case \"dex\":\n                abilities[ability].name = \"Dexterity\"\n                break;\n            case \"con\":\n                abilities[ability].name = \"Constitution\"\n                break;\n            case \"int\":\n                abilities[ability].name = \"Intelligence\"\n                break;\n            case \"wis\":\n                abilities[ability].name = \"Wisdom\"\n                break;\n            case \"cha\":\n                abilities[ability].name = \"Charisma\"\n                break;\n            default:\n                console.log(\"something went wrong\");\n        }\n        template += `<option value=\"${ability}\">${abilities[ability].name} (${abilities[ability].value})</option>`;\n    }\n    template += `</select>\n        </div>\n    </div>`\n\n\n    new Dialog({\n        title: tool.name,\n        content: template,\n        buttons: {\n            ok: {\n                icon: '<i class=\"fas fa-check\"></i>',\n                label: \"OK\",\n                callback: async (html) => {\n                    const selection = html.find(\"#selectedAbility\")[0].value;\n                    console.log(tool, target);\n                    let prof = tool.data.data.proficient * target.data.data.attributes.prof; // target might be half or doubly proficient. This will make sure it is accounted for\n                    let bonusattack = tool.data.data.attackBonus\n\t\t    let typeac = tool.data.data.actionType\n\t\t    const globalbonus = tool.data.data.actionType == \"mwak\" ? target.data.data.bonuses.mwak.attack : target.data.data.bonuses.rwak.attack\n                    let messageContent = `${target.name} Rolou Dado 1: <b>[[1d20+${abilities[selection].mod}+${prof}+${bonusattack}+${globalbonus}]]</b> e Dado 2: <b>[[1d20+${abilities[selection].mod}+${prof}+${bonusattack}+${globalbonus}]]</b> para a ação  de desarmar com ${tool.name}. Utilize dado 1 caso não tenha vantagem nem desvantgem. [[1d20+${abilities[selection].mod}(${abilities[selection].name})+${prof}(Proficiency)+${bonusattack}(Bonus Arma)+${globalbonus}(Bonus global)]]</b><br>`;\n                    let chatData = {\n                        user: game.user.id,\n                        speaker: ChatMessage.getSpeaker(),\n                        content: messageContent,\n                        // uncomment the line below to always whisper the roll to the GM\n                        // whisper: game.users.entities.filter(u => u.isGM).map(u => u._id)\n                    };\n                    ChatMessage.create(chatData, {});\n               }\n            },\n            cancel: {\n                icon: '<i class=\"fas fa-times\"></i>',\n                label: 'Cancel'\n            }\n        },\n        default: \"cancel\"\n    }).render(true);\n})\n\n// Choose tool dialog\nif (toolsInInventory.length) {\n    (async () => {\n        let template = `\n        <div>\n            <div class=\"form-group\">\n                <label>Choose a tool</label>\n                <select id=\"selectedTool\">`\n        toolsInInventory.forEach( tempTool => {    \n            template += `<option value=\"${tempTool.name}\">${tempTool.name}</option>`;\n        });\n        template += `</select>\n            </div>\n        </div>`;\n\n        new Dialog({\n            title: 'Which tool?',\n            content: template,\n            buttons: {\n                ok: {\n                    icon: '<i class=\"fas fa-check\"></i>',\n                    label: \"OK\",\n                    callback: async (html) => {\n                        let selection = html.find(\"#selectedTool\")[0].value;\n                        tool = toolsInInventory.find( item => item.name === selection )\n                        abilityDialog();\n                   }\n                },\n                cancel: {\n                    icon: '<i class=\"fas fa-times\"></i>',\n                    label: 'Cancel'\n                }\n            },\n            default: \"cancel\"\n        }).render(true);\n    })()    \n}\n\nelse {\t\n    new Dialog({\n        title: 'No Tools!',\n        content: '<p>You don\\'t seem to have any tool with you.</p>',\n        buttons: {\n            ok: {\n                icon: '<i class=\"fas fa-check\"></i>',\n                label: \"OK\"\n            }\n        },\n        default: \"ok\"\n    }).render(true);\n}}) ()\nlet Cub_Condition = game.macros.getName(\"Cub_Condition\");\nlet target = Array.from(game.user.targets)[0];\nlet me = canvas.tokens.controlled[0].actor;\nlet getAcr = target.actor.data.data.skills.acr.total;\nlet getAth = target.actor.data.data.skills.ath.total;\nlet bestSkill = getAcr > getAth ? \"acr\" : \"ath\";\nlet skillRoll = await target.actor.rollSkill(bestSkill);\n})()\n                 } }, // two\n            four: {\n                label: \"Escalar\",\n                callback: async () => {\n(async()=>{\nlet Cub_Condition = game.macros.getName(\"Cub_Condition\");\nlet target = Array.from(game.user.targets)[0];\nlet me = canvas.tokens.controlled[0].actor;\nlet meath = actor.data.data.skills.ath.total\nlet meacr = actor.data.data.skills.acr.total\nlet bestSkill = meacr > meath ? \"acr\" : \"ath\";\nlet athRoll = await me.rollSkill(bestSkill);\nlet skillRoll = await target.actor.rollSkill('acr');\n\nlet success = \"\";\nif(athRoll.total > skillRoll.total) {\nsuccess = \"Atropelou com Sucesso\";\nlet the_message = `${me.name} <span style=\"color: blue\"><b> ${success}</b> </span> ${target.name}. Você pode se mover pelo espaço da\ncriatura maior, considerando o espaço como terreno difícil. <b>Você se move com o alvo e tem vantagem nas jogadas de ataque contra ele</b>.`;\nChatMessage.create({\n    user: game.user._id,\n    speaker: ChatMessage.getSpeaker({actor: me}),\n    content: the_message,\n});\n} else {\nsuccess = \"Falhou em Escalar\";\nlet the_message = `${me.name} <span style=\"color: red\"><b> ${success}</b> </span> ${target.name}.`;\nChatMessage.create({\n    user: game.user._id,\n    speaker: ChatMessage.getSpeaker({actor: me}),\n    content: the_message,\n});\n}\n\n})();\n                       }\n                 }, ////// fim escalar\n            three: {\n                label: \"Atropelar\",\n                callback: async () => {\n(async()=>{\nlet Cub_Condition = game.macros.getName(\"Cub_Condition\");\nlet target = Array.from(game.user.targets)[0];\nlet me = canvas.tokens.controlled[0].actor;\nlet athRoll = await me.rollSkill('ath');\nlet getAcr = target.actor.data.data.skills.ath.total;\nlet getAth = target.actor.data.data.skills.ath.total;\nlet bestSkill = getAcr > getAth ? \"ath\" : \"ath\";\nlet skillRoll = await target.actor.rollSkill(bestSkill);\n\nlet success = \"\";\nif(athRoll.total > skillRoll.total) {\nsuccess = \"Atropelou com Sucesso\";\nlet the_message = `${me.name} <span style=\"color: blue\"><b> ${success}</b> </span> ${target.name}. Você pode se mover pelo espaço da criatura nesse turno.`;\nChatMessage.create({\n    user: game.user._id,\n    speaker: ChatMessage.getSpeaker({actor: me}),\n    content: the_message,\n});\n} else {\nsuccess = \"Falhou em Atropelar\";\nlet the_message = `${me.name} <span style=\"color: red\"><b> ${success}</b> </span> ${target.name}.`;\nChatMessage.create({\n    user: game.user._id,\n    speaker: ChatMessage.getSpeaker({actor: me}),\n    content: the_message,\n});\n}\n\n})();\n                       } \n            }, // fim atropelar\n\n            five: {\n                label: \"Cambalhota\",\n                callback: async () => {\n(async()=>{\nlet Cub_Condition = game.macros.getName(\"Cub_Condition\");\nlet target = Array.from(game.user.targets)[0];\nlet me = canvas.tokens.controlled[0].actor;\nlet athRoll = await me.rollSkill('acr');\nlet getAcr = target.actor.data.data.skills.acr.total;\nlet getAth = target.actor.data.data.skills.acr.total;\nlet bestSkill = getAcr > getAth ? \"acr\" : \"acr\";\nlet skillRoll = await target.actor.rollSkill(bestSkill);\n\nlet success = \"\";\nif(athRoll.total > skillRoll.total) {\nsuccess = \"Cambalhota com Sucesso em\";\nlet the_message = `${me.name} <span style=\"color: blue\"><b> ${success}</b> </span> ${target.name}. Você pode se mover pelo espaço da criatura nesse turno.`;\nChatMessage.create({\n    user: game.user._id,\n    speaker: ChatMessage.getSpeaker({actor: me}),\n    content: the_message,\n});\n} else {\nsuccess = \"Falhou na cambalhota\";\nlet the_message = `${me.name} <span style=\"color: red\"><b> ${success}</b> </span> ${target.name}.`;\nChatMessage.create({\n    user: game.user._id,\n    speaker: ChatMessage.getSpeaker({actor: me}),\n    content: the_message,\n});\n}\n\n})();\n                       } \n            }, // fim cambalhota\n\n           eight: {\n                label: \"Escapar agarrão (Grapple)\",\n                callback: async () => {\n(async()=>{\nlet Cub_Condition = game.macros.getName(\"Cub_Condition\");\nlet target = Array.from(game.user.targets)[0];\nconst mess = canvas.tokens.controlled[0].actor.uuid;\nlet me = canvas.tokens.controlled[0].actor;\nlet meath = actor.data.data.skills.ath.total\nlet meacr = actor.data.data.skills.acr.total\nlet meSkill = meacr > meath ? \"acr\" : \"ath\";\nlet meRoll = await me.rollSkill(meSkill);\nlet getAcr = target.actor.data.data.skills.ath.total;\nlet getAth = target.actor.data.data.skills.ath.total;\nlet bestSkill = getAcr > getAth ? \"ath\" : \"ath\";\nlet skillRoll = await target.actor.rollSkill(bestSkill);\n\nlet success = \"\";\nif(meRoll.total > skillRoll.total) {\n  await game.dfreds.effectInterface.removeEffect({effectName:\"Grappled\", uuid:mess});\nsuccess = \"Saiu do agarrão com Sucesso\";\nlet the_message = `${me.name} <span style=\"color: blue\"><b> ${success}</b> </span> ${target.name}.`;\nChatMessage.create({\n    user: game.user._id,\n    speaker: ChatMessage.getSpeaker({actor: me}),\n    content: the_message,\n});\n} else {\nsuccess = \"Falhou em sair do Agarrarão\";\nlet the_message = `${me.name} <span style=\"color: red\"><b> ${success}</b> </span> ${target.name}.`;\nChatMessage.create({\n    user: game.user._id,\n    speaker: ChatMessage.getSpeaker({actor: me}),\n    content: the_message,\n});\n}\n\n})();\n\n                       } // fim async content\n                 }, // fim escapar\n\n\n} }).render(true);//fim função","flags":{"combat-utility-belt":{"macroTrigger":""},"advanced-macros":{"runAsGM":false,"runForSpecificUser":""},"exportSource":{"world":"criador","system":"dnd5e","coreVersion":"0.8.8","systemVersion":"1.3.6"},"macro-marker":{"activeData":{"icon":"modules/GMmacros/img/acoes_adicionais.png","tooltip":"Ações_extras"}},"core":{"sourceId":"Macro.biIFauGQz2Xs9pkZ"}},"ownership":{"default":3,"QwT9izJ4aW8QVTjo":3,"Be8r6Sgxcs3sL08I":3},"_stats":{"systemId":"dnd5e","systemVersion":"2.1.5","coreVersion":"10.291","createdTime":1668381000745,"modifiedTime":1685293665027,"lastModifiedBy":"Be8r6Sgxcs3sL08I"},"folder":null,"sort":0,"_id":"RkDOzSVhjVus7tyf"}
{"name":"Activate effect suspended","type":"script","scope":"global","author":"Be8r6Sgxcs3sL08I","img":"icons/svg/dice-target.svg","command":"const effect = actor.effects.find(e => e.data.label === \"Emissary of Redemption\");\nif(!effect.disabled) {\n    await effect.update({ disabled: true });\n} else {\nawait effect.update({ disabled: false });}","ownership":{"default":0,"Be8r6Sgxcs3sL08I":3},"flags":{"advanced-macros":{"runAsGM":false,"runForEveryone":false,"runForSpecificUser":""},"core":{"sourceId":"Macro.WgvsACwCs4kf6xZO"}},"_stats":{"systemId":"dnd5e","systemVersion":"2.0.3","coreVersion":"10.290","createdTime":1670004676757,"modifiedTime":1670007927726,"lastModifiedBy":"Be8r6Sgxcs3sL08I"},"folder":null,"sort":0,"_id":"SEjSi6K7SP7HRE4C"}
{"name":"Emissary_of_Redemption_1","type":"script","scope":"global","author":"Be8r6Sgxcs3sL08I","img":"icons/svg/dice-target.svg","command":"const workflow = MidiQOL.Workflow.getWorkflow(args[0].uuid); \nif (args[0].hitTargetUuids.length === 0) return {}\nconst tactor = (Array.from(workflow.targets))[0]?.actor; \nif (tactor?.effects.find(i=>i.data.label === \"Emissary of Redemption Attacked\")) {return} else {\n\tlet bsEffect = new ActiveEffect({label: \"Emissary of Redemption Attacked\", \n\t\t\t\t icon: \"modules/GMmacros/img/Emissary_redemption.png\"});\n\tfor (let tokenUuid of args[0].hitTargetUuids) {\n        \tconst target = await fromUuid(tokenUuid);\n        \tconst targetActor = target.actor;\n       \t\tif (!targetActor) continue;\n\t\tawait MidiQOL.socket().executeAsGM(\"createEffects\", {actorUuid: targetActor.uuid, effects: [bsEffect.toObject()]})\n }\n}","ownership":{"default":0,"Be8r6Sgxcs3sL08I":3},"flags":{"advanced-macros":{"runAsGM":true,"runForSpecificUser":""},"core":{"sourceId":"Macro.HWPAGjNnWkvDoTi1"}},"_stats":{"systemId":"dnd5e","systemVersion":"2.1.5","coreVersion":"10.291","createdTime":1686595886014,"modifiedTime":1686614353920,"lastModifiedBy":"Be8r6Sgxcs3sL08I"},"folder":null,"sort":0,"_id":"VnLNDtVNgVsKuHS3"}
