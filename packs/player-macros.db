{"name":"Sneak Attack-Liga/Desliga","permission":{"default":0,"NeG597KOgANJAOdY":3},"type":"script","flags":{"macro-marker":{"activeData":{"icon":"systems/dnd5e/icons/skills/violet_27.jpg","tooltip":"Sneak Attack","colour":"#5945bf","trigger":""},"markers":{"markers":{"7rVA5gxptaEoIlko":false},"type":"Token"}},"combat-utility-belt":{"macroTrigger":""},"core":{"sourceId":"Macro.hqzyhAjIeRfEca6K"}},"scope":"global","command":"//\t\tDISCLAIMER:\t\tThis macro is heavily based on the original D&D 5e Rage Macro masterwork written by Felix#6196.\n//\t\t\t\t\t\tNorc#5108 created and is maintaining this macro.\n//\n//\t\t\t\t\t\tUpdates:\t1.\t2020/06/05: Initial version.\n\n//!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n//!!!\tBonus Tip: Sneak Attack as a Condition                                                                                                                       \n//!!!\tIf you use the Combat Utility Belt module's Condition Lab, try adding a condition called \"Sneaky\" with the same icon \t\t\t   \n//!!!\tas the optional sneak attack icon overlay, 'icons/svg/mystery-man-black.svg' by default.  See EXPERIMENTAL MACRO ICON/NAME TOGGLE below.\n//!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n\n//!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n//!!!   OPTIONAL TOKEN ICON-\tOn by default. If a path to a sneak attack icon is defined, it displays like a condition on the sneaking rogue.\n//!!!\t\t\t\t\t\t\tTo use a different icon, manually change the filepath below or leave it empty ('') to disable the effect.\n//!!!\nconst sneakIconPath = 'systems/dnd5e/icons/skills/violet_27.jpg';\n//!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n\n//!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n//!!!\tEXPERIMENTAL MACRO ICON/NAME TOGGLE\t\tIf enabled, the macro icon and name toggles based on whether the rogue is currently sneaking. \n//!!!\t\t\t\t\t\t\t\t\t\t\tCAUTIONS: \t1. \tThis feature is off by default and is intended for ADVANCED USERS ONLY. \n//!!!\t\t\t\t\t\t\t\t\t\t\t\t\t\t2. \tRequires configuration using \"The Furnace\" module for a player to run!\n//!!!\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tThe GM needs to grant The Furnace's \"Run as GM\" permission for this macro.\n//!!!\t\t\t\t\t\t\t\t\t\t\t\t\t\t3. \tWorks best with only one rogue using this feature at a time.\n\n\t\t\t\t//To auto-toggle the macro's icon/name, override toggleMacro to true below.\n\t\t\t\tconst toggleMacro = false;\n\n\t\t\t\t//To use a different icon, manually change the filepath here\n\t\t\t\tconst stopSneakIconPath = 'icons/svg/cowled.svg';\n\n\t\t\t\t//You must update the following constant to this macro's exact name for the macro icon toggling to work.\n\t\t\t\tconst sneakMacroName = 'Sneak Attack';\n//!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n\nlet toggleResult = false;\nlet enabled = false;\nlet errorReason = '';\nlet sneakAttack = {};\nlet rogue = {};\nlet rogueLvls = 0;\nlet sneakDice = 0;\nlet chatMsg = '';\nlet oldMDmg = '';\nlet oldRDmg = '';\n\nlet macroActor = actor;\nlet macroToken = token;\n\n//!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n//!!!\tBASIC LOCALIZATION SUPPORT\t\t\t\tSets names of D&D5E features as constants instead of hardcoding to allow easier translation.\n//!!!\t\t\t\t\t\t\t\t\t\t\tSets error messages as constants also for easier translation.\n\n\t\t\t\tconst rogueClassName = 'Rogue';\n\t\t\t\tconst sneakAttackFeatureName = 'Sneak Attack';\n\n\t\t\t\tconst errorSelectRogue = 'Please select a single rogue token.';\n\t\t\t\tconst warnMacroNotFound = ' is not a valid macro name, please fix. Sneak attack toggle successful but unable to alter macro.';\n\t\t\t\tconst errorSelectToken = 'Please select a token.';\n//!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n\n\n//check to ensure token is selected and attempt to define the sneak attack feature\nif (macroActor !== null && macroActor !== undefined) {\n\tsneakAttack = macroActor.items.find(i => i.name == `${sneakAttackFeatureName}`);\n} else {\nerrorReason = `${errorSelectToken}`;\n}\n\n//check to ensure token is a rogue\nif (errorReason == '' && macroActor.items.find(i => i.name == `${rogueClassName}`) !== undefined) {\n\trogue = macroActor.items.find(i => i.name == `${rogueClassName}`);\n} else {\n\terrorReason = `${errorSelectRogue}`;\n}\n\nconsole.log(`Error reason is: ${errorReason}`);\n//main execution now that errors are caught\n\nif (errorReason == '') {\n\t\n\tchatMsg = '';\n\tlet enabled = false;\n\t// store the state of the sneak attack toggle in flags\n\tif (macroActor.data.flags.sneakMacro !== null && macroActor.data.flags.sneakMacro !== undefined) {\n\t\tenabled = true;\n\t}\n\t\n\t// if sneak attack is active, disable it\n\tif (enabled) {\n\t\tchatMsg = `${macroActor.name} is no longer sneak attacking.`;\n\t\t// ranged and melee weapon attack bonus\n\t\tlet obj = {};\n\t\tobj['flags.sneakMacro'] = null;\t\t\n\t\tobj['data.bonuses.mwak.damage'] = macroActor.data.flags.sneakMacro.oldMDmg;\t\t\t\n\t\tobj['data.bonuses.rwak.damage'] = macroActor.data.flags.sneakMacro.oldRDmg;\t\n\t\tmacroActor.update(obj);\n\t\t\n\t// if sneak attack is disabled, enable it\n\t} else {\t\t\n\t\tchatMsg = `${macroActor.name} starts sneak attacking!`;\n\t\t\n\t\tlet obj = {};\n\t\tobj['flags.sneakMacro.enabled'] = true;\n\n\t\t// Preserve old mwak damage bonus if there was one\n\t\tlet oldMDmg = macroActor.data.data.bonuses.mwak.damage;\n\t\tif (oldMDmg==null || oldMDmg == undefined || oldMDmg == '') oldMDmg = 0;\n\t\tobj['flags.sneakMacro.oldMDmg'] = JSON.parse(JSON.stringify(oldMDmg));\n\n\t\t// Preserve old rwak damage bonus if there was one\n\t\tlet oldRDmg = macroActor.data.data.bonuses.rwak.damage;\n\t\tif (oldRDmg==null || oldRDmg == undefined || oldRDmg == '') oldRDmg = 0;\n\t\tobj['flags.sneakMacro.oldRDmg'] = JSON.parse(JSON.stringify(oldRDmg));\n\n\t\t\n\t\t// Determining the rogue level\n\t\trogueLvls = rogue.data.data.levels;\n\n\t\t// Formula to determine the sneak attack damage depending on rogue level\t\n\t\tsneakDice = Math.ceil(rogueLvls/2);\n\t\n\t\t//actually add the bonus sneak attack damage to the previous bonus damage\n\t\t//respect roll formulas if present.\n\t\tif (oldMDmg==null || oldMDmg == undefined || oldMDmg == '' || oldMDmg == 0) {\n\t\t\tobj['data.bonuses.mwak.damage'] = `${sneakDice}d6`;\n\t\t} else {\n\t\t\tobj['data.bonuses.mwak.damage'] = `${oldMDmg} + ${sneakDice}d6`;\n\t\t}\n\n\t\tif (oldRDmg==null || oldRDmg == undefined || oldRDmg == '' || oldRDmg == 0) {\n\t\t\tobj['data.bonuses.rwak.damage'] = `${sneakDice}d6`;\n\t\t} else {\n\t\t\tobj['data.bonuses.rwak.damage'] = `${oldRDmg} + ${sneakDice}d6`;\n\t\t}\t\n\n\t\tmacroActor.update(obj);\n\n\t}\t\n\t\n\t//mark or unmark character's token with Sneaky effect icon, if sneakIconPath is defined\n\t(async () => { \n\t\ttoggleResult = await macroToken.toggleEffect(sneakIconPath);\n\t\tif (toggleResult == enabled) macroToken.toggleEffect(sneakIconPath);  \n\t})();\n\n\t//toggle macro icon and name, if enabled\n\tif (toggleMacro) {\n//\t\tNorc's preferred icons, not sure if publicly available\n//\t\tsneakyMacroImgPath = 'systems/dnd5e/icons/skills/shadow_17.jpg';\n//\t\tstopSneakIconPath = 'systems/dnd5e/icons/skills/yellow_11.jpg';\n\t\tlet sneakMacro = game.macros.getName(sneakMacroName);\n\t\t\t//Also check for name of macro in its \"off\" form\n\t\t\tif (sneakMacro == null || sneakMacro == undefined) {\n\t\t\t\tsneakMacro = game.macros.getName('Stop ' + sneakMacroName);\n\t\t\t}\n\t\tlet obj = {};\n\t\tif ( (sneakMacro !== null && sneakMacro !== undefined) && \n\t\t\t\t+ (stopSneakIconPath !== null && stopSneakIconPath !== undefined && stopSneakIconPath !== '') ) {\n\t\t\tif (enabled) {\n\t\t\tobj['img'] = sneakIconPath;\n\t\t\tobj['name'] = sneakMacroName;\n\t\t\t} else {\n\t\t\tobj['img'] = stopSneakIconPath;\n\t\t\tobj['name'] = 'Stop ' + sneakMacroName;\n\t\t\t}\n\t\t\tsneakMacro.update(obj);\n\t\t} else {\n\t\tui.notifications.warn(`${sneakMacroName} ${warnMacroNotFound}`);\t\t\t\n\t\t}\n\t}\n\n} else {\nui.notifications.error(`${errorReason}`);\t\n}\nif (chatMsg !== '') {\n\tlet chatData = {\n\t\tuser: game.user._id,\n\t\tspeaker: ChatMessage.getSpeaker(),\n\t\tcontent: chatMsg\n\t};\n\tChatMessage.create(chatData, {});\n}\nif (token)\n  MacroMarker.toggle(this, { entity: token });","author":"NeG597KOgANJAOdY","img":"systems/dnd5e/icons/skills/violet_27.jpg","actorIds":[],"_id":"9J8wIqeIwOW76LOq"}
{"name":"Hexblade-Liga/Desliga","permission":{"default":0,"NeG597KOgANJAOdY":3},"type":"script","flags":{"macro-marker":{"activeData":{"icon":"icons/svg/dice-target.svg","tooltip":"New Macro","colour":"#ff0000","trigger":""}},"combat-utility-belt":{"macroTrigger":""},"furnace":{"runAsGM":false},"core":{"sourceId":"Macro.8Guutr7R1Tddogoy"}},"scope":"global","command":"//------------------------------------------------------\n// Hexblade's Curse Toggle\n//     Toggles the bonus damage to weapon and spell\n//     attacks as well as the critical hit range change\n//     due to Hexblade's Curse for dnd5e characters.\n//\n//     It whispers the toggle's status to the GM,  and \n//     shows an icon on the character's token when \n//     the effect is active.\n//\n//     The only set-up that is required, is putting the\n//     warlock's character id below here. You can find \n//     this id by right-clicking on an Actor in Foundry\n//     and selecting Export Data. The very first field in\n//     the .json file is called \"_id\" and the string following\n//     it is the id you need.\n//------------------------------------------------------\nconst hexActor = game.actors.get(\"j89JNMFVXG2anMX4\");\n//------------------------------------------------------\n\nconst currentCritThreshold = hexActor.getFlag(\"dnd5e\",\"weaponCriticalThreshold\")\nconst hexToken = hexActor.getActiveTokens()[0];\nconst prof = hexActor.data.data.attributes.prof;\n\nif (currentCritThreshold == 20) {\n    hexToken.toggleEffect(\"systems/dnd5e/icons/spells/phb-branding-smite.jpg\");\nhexActor.setFlag(\"dnd5e\",\"weaponCriticalThreshold\",19);\nconsole.log(\"Melee weapon attack damage bonus:\",hexActor.data.data.bonuses.mwak.damage)\nconsole.log(\"Proficiency bonus:\",hexActor.data.data.attributes.prof)\nlet updates = {\n'data.bonuses.mwak.damage': prof,\n'data.bonuses.rwak.damage': prof,\n'data.bonuses.msak.damage': prof,\n'data.bonuses.rsak.damage': prof\n};\nhexActor.update(updates);\n//console.log(\"Hexblade's Curse Activated\");\nlet msgContent = \"Hexblade's Curse: Target Acquired\";\nlet chatData = {\n  user:  game.user.id,\n  speaker: game.user,\n  content:  msgContent,\n  //whisper: game.users.entities.filter(u => u.isGM).map(u => u._id)\n};\nChatMessage.create(chatData,{});\n} else {\n    hexToken.toggleEffect(\"systems/dnd5e/icons/spells/phb-branding-smite.jpg\");\nhexActor.setFlag(\"dnd5e\",\"weaponCriticalThreshold\",20);\nlet updates = {\n'data.bonuses.mwak.damage': 0,\n'data.bonuses.rwak.damage': 0,\n'data.bonuses.msak.damage': 0,\n'data.bonuses.rsak.damage': 0\n};\nhexActor.update(updates);\n//console.log(\"Hexblade's Curse Deactivated\");\nlet msgContent = \"Hexblade's Curse: Target Lost\";\nlet chatData = {\n  user:  game.user.id,\n  speaker: game.user,\n  content:  msgContent,\n  //whisper: game.users.entities.filter(u => u.isGM).map(u => u._id)\n};\nChatMessage.create(chatData,{});\n}","author":"NeG597KOgANJAOdY","img":"systems/dnd5e/icons/spells/enchant-orange-3.jpg","actorIds":[],"_id":"CXa9qsNBi2lfTTt0"}
{"name":"Lay on Hands-Macro","permission":{"default":0,"NeG597KOgANJAOdY":3},"type":"script","flags":{"macro-marker":{"activeData":{"icon":"icons/svg/dice-target.svg","tooltip":"New Macro","colour":"#ff0000","trigger":""}},"combat-utility-belt":{"macroTrigger":""},"furnace":{"runAsGM":true},"core":{"sourceId":"Macro.cT2KBUzNq68HEt8X"}},"scope":"global","command":"/**\n * System: D&D5e\n * Apply lay-on-hands feat to a target character.  Asks the player how many HP to heal and\n * verifies the entered value is within range before marking down usage counter. If the player\n * has OWNER permissions of target (such as GM or self-heal) the HP are applied automatically; \n * otherwise, a 'roll' message appears allowing the target character to right-click to apply healing.\n */\n\nlet confirmed = false;\nlet actorData = actor || canvas.tokens.controlled[0] || game.user.character;\nlet featData = actorData ? actorData.items.find(i => i.name===\"Lay on Hands\") : null;\n\nif(actorData == null || featData == null) \n    ui.notifications.warn(`Selected hero must have \"Lay on Hands\" feat.`);\nelse if (game.user.targets.size !== 1)\n    ui.notifications.warn(`Please target one token.`);\nelse\n{\n    let featUpdate = duplicate(featData);\n    let targetActor = game.user.targets.values().next().value.actor;\n    let maxHeal = Math.clamped(featUpdate.data.uses.value, 0, \n        targetActor.data.data.attributes.hp.max - targetActor.data.data.attributes.hp.value);\n\n    let content = `<p><em>${actorData.name} lays hands on ${targetActor.data.name}.</em></p>\n                    <p>How many HP do you want to restore to ${targetActor.data.name}?</p>\n                    <form>\n                        <div class=\"form-group\">\n                            <label for=\"num\">HP to Restore: (Max = ${maxHeal})</label>\n                            <input id=\"num\" name=\"num\" type=\"number\" min=\"0\" max=\"${maxHeal}\"></input>\n                        </div>\n                        <div class=\"form-group\">\n                            <label for=\"flavor\">Flavor:</label>\n                            <input id=\"flavor\" name=\"flavor\" value=\"${featUpdate.data.chatFlavor}\"></input>\n                        </div>\n                    </form>`;\n    new Dialog({\n        title: \"Lay on Hands Healing\",\n        content: content,      \n        buttons: {\n            heal: { label: \"Heal!\", callback: () => confirmed = true },\n            cancel: { label: \"Cancel\", callback: () => confirmed = false }\n        },\n        default: \"heal\",\n\n        close: html => {\n            if (confirmed) \n            {\n                let number = Math.floor(Number(html.find('#num')[0].value));\n                if (number < 1 || number > maxHeal)\n                    ui.notifications.warn(`Invalid number of charges entered = ${number}. Aborting action.`);\n                else\n                {\n                    let flavor = `<strong>${html.find('#flavor')[0].value}</strong><br>`;\n                    if (targetActor.permission !== CONST.ENTITY_PERMISSIONS.OWNER)\n                        // We need help applying the healing, so make a roll message for right-click convenience.\n                        new Roll(`${number}`).roll().toMessage({\n                            speaker: ChatMessage.getSpeaker(),\n                            flavor: `${actorData.name} lays hands on ${targetActor.data.name}.<br>${flavor}\n                            <p><em>Manually apply ${number} HP of healing to ${targetActor.data.name}</em></p>` });\n                    else {\n                        // We can apply healing automatically, so just show a normal chat message.\n                        ChatMessage.create({\n                            speaker: ChatMessage.getSpeaker(),\n                            content: `${actorData.name} lays hands on ${targetActor.data.name} for ${number} HP.<br>${flavor}`\n                        });\n                        game.actors.find(a => a._id===targetActor._id).update( {\n                            \"data.attributes.hp.value\" : targetActor.data.data.attributes.hp.value + number\n                        });\n                    }\n\n                    featUpdate.data.uses.value = featUpdate.data.uses.value - number;\n                    actorData.updateEmbeddedEntity(\"OwnedItem\", featUpdate);\n                };\n            }\n        }\n    }).render(true);\n}","author":"NeG597KOgANJAOdY","img":"systems/dnd5e/icons/skills/light_10.jpg","actorIds":[],"_id":"H8guYT3SVvLfNPC4"}
{"name":"Great Weapon Master-Liga/Desliga","permission":{"default":0,"NeG597KOgANJAOdY":3},"type":"script","flags":{"macro-marker":{"activeData":{"icon":"systems/dnd5e/icons/skills/yellow_16.jpg","tooltip":"Great Weapon Master","colour":"#bfb318","trigger":""}},"combat-utility-belt":{"macroTrigger":""},"core":{"sourceId":"Macro.67CT6aSibj7HD3ro"},"furnace":{"runAsGM":false}},"scope":"global","command":"/*\nCreated Monkan#8752 with guidance from the Rage macro in the FVTT Community Macros\n\nTips to make it work\n 1 -    Have a feature called 'Great Weapon Master' for your character.\n 2 -    Make sure you have your weapons with Heavy property filled out. \n 3 -    if you make any changes to your damage or attack calculations, make sure you toggle it off.\n        As it stores the old values to replace once you disable the feat.  It could undo your changes.\n*/\n\nlet gwm='';\nlet chatMsg='';\n\n\nif (actor !== undefined && actor !== null) {\n    // find the feat Great Weapon Master\n    gwm = actor.items.find(i => i.name === 'Great Weapon Master');\n    if (gwm == undefined) { \n        ui.notifications.warn(\"Please select a single token with the Great Weapon Master feat.\");        \n    }\n\n    if (gwm !== undefined && gwm !== null) {\n\t\tchatMsg = '';\n\t\tlet enabled = false;\n\t\t// store the state of the GWM toggle in flags\n\t\tif (actor.data.flags.gwmMacro !== null && actor.data.flags.gwmMacro !== undefined) {\n\t\t\tenabled = true;\n\t\t}\n\t\t// if GWM is active, disable it\n\t\tif (enabled) {\n            chatMsg = `${actor.name} - GWM desligado.`;\n            \n            let obj = {};\n\t\t\tobj['flags.gwmMacro'] = null;\t\t\t\n\t\t\tactor.update(obj);\n\n\t\t\t// reset items\n\t\t\tfor (let item of actor.items) {\n\t\t\t\tif (item.data.flags.gwmMacro !== null && item.data.flags.gwmMacro !== undefined) {\n\t\t\t\t\t// restoring the old value from flags\n                    let oldDmg = item.data.flags.gwmMacro.oldDmg;\n                    let oldAtk = item.data.flags.gwmMacro.oldAtk;\n\t\t\t\t\tlet obj = {};\n                    obj['data.damage.parts'] = oldDmg;\n                    obj['data.attackBonus'] = oldAtk;\n\t\t\t\t\tobj['flags.gwmMacro'] = null;\n\t\t\t\t\titem.update(obj);\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t// if GWM is disabled, enable it\n\t\t} else {\n            chatMsg = `${actor.name} GWM Ligado!`;\n            \n            let obj = {};\n\t\t\tobj['flags.gwmMacro.enabled'] = true;\n\t\t\tactor.update(obj);\n\n            // update items\n            let gwmAtk = -5;\n\t\t\tlet gwmDmg = 10;\n\t\t\tfor (let item of actor.items) {\n                let isMelee = getProperty(item, 'data.data.actionType') === 'mwak';\n                let isHeavy = getProperty(item, 'data.data.properties.hvy')\n\t\t\t\tif (isMelee && isHeavy && item.data.data.damage.parts.length > 0) {\n\t\t\t\t\tconsole.log('updating ' + item);\n                    let obj = {};\n                    let atk = item.data.data.attackBonus;\n                    let dmg = item.data.data.damage.parts;\n                    // Save old attack and damage values\n                    obj['flags.gwmMacro.oldDmg'] = JSON.parse(JSON.stringify(dmg));\n                    obj['flags.gwmMacro.oldAtk'] = JSON.parse(JSON.stringify(atk));\n                    // Set the new attack and damage values\n                    if (atk !== null) {\n                        atk += '' + gwmAtk;\n                    } else {\n                        atk = gwmAtk;\n                    }\n\t\t\t\t\tdmg[0][0] = `${dmg[0][0]} + ${gwmDmg}`;\n                    obj['data.damage.parts'] = dmg;\n                    obj['data.attackBonus'] = atk;\n\t\t\t\t\titem.update(obj);\n\t\t\t\t}\n\t\t\t}\n\n\t\t}\n    }\n\n} else ui.notifications.warn(\"Please select a token.\");\n\n// write to chat if needed:\nif (chatMsg !== '') {\n\tlet chatData = {\n\t\tuser: game.user._id,\n\t\tspeaker: ChatMessage.getSpeaker(),\n\t\tcontent: chatMsg\n    };\n\tChatMessage.create(chatData, {});\n}\nif (token)\n  MacroMarker.toggle(this, { entity: token });","author":"NeG597KOgANJAOdY","img":"systems/dnd5e/icons/skills/yellow_16.jpg","actorIds":[],"_id":"JhJeeBPZ5W8cu5FV"}
{"name":"Dodge-action","permission":{"default":0,"z3axZ8yAkgVHJACm":3},"type":"script","flags":{"macro-marker":{"activeData":{"icon":"icons/svg/dice-target.svg","tooltip":"New Macro","colour":"#ff0000","trigger":""}},"combat-utility-belt":{"macroTrigger":""},"furnace":{"runAsGM":false},"core":{"sourceId":"Macro.Tnx74XaZaMyuJXT0"}},"scope":"global","command":"// requer uma condition CUB chamada Dodge com as flags adicionadas.\nif(!game.cub.hasCondition(\"Dodge\")) return game.cub.addCondition(\"Dodge\");\ngame.cub.removeCondition(\"Dodge\");","author":"z3axZ8yAkgVHJACm","img":"modules/GMmacros/img/defensive-stance.jpg","actorIds":[],"_id":"ij4VriAqSjTYqtV3"}
{"name":"Rage-Macro-Liga/Desliga","permission":{"default":0,"NeG597KOgANJAOdY":3},"type":"script","flags":{"macro-marker":{"activeData":{"icon":"systems/dnd5e/icons/skills/red_10.jpg","tooltip":"Rage-Macro","colour":"#ff6600","trigger":""},"markers":{"markers":{"jv8ZYVc1mcpm4svY":true},"type":"Token"}},"combat-utility-belt":{"macroTrigger":""},"core":{"sourceId":"Macro.CgAyK40KyztIirYa"}},"scope":"global","command":"//\t\tDISCLAIMER:\t\tThis macro is an evolved version of the original D&D 5e Rage Macro masterwork written by Felix#6196.\n//\t\t\t\t\t\tNorc#5108 is now maintaining this macro along with continued support from Felix.\n//\n//\n//\t\tUPDATES:\t\t1.\tFixed errors resulting from declarations of \"actor\" and \"token\" in a script macro. \n//\t\t\t\t\t\t\tAdded automatic Totem Spirit: Bear detection and resistance application \n//\t\t\t\t\t\t\tAdded error messages for trying to rage with no token or no barbarian selected\n//\t\t\t\t\t\t2.\t(Felix) Added resource/usage deduction and errors (re-added after accidentally overwriting the addition)\n//\t\t\t\t\t\t\tFixed rage damage at level 8\n//\t\t\t\t\t\t3.\t(2020/05/30) \"Version 2.0\" \t\n//\t\t\t\t\t\t\tImplemented Felix's idea to use global melee weapon attack bonus instead of modifying items\n//\t\t\t\t\t\t\tImproved Rage icon toggling to be more reliable\n//\t\t\t\t\t\t\tRemoved code from the resource management that created dependency on The Furnace Advanced Macros\n//\t\t\t\t\t\t\tImplemented Felix's fix for issue where new resistances and rage uses were not saving properly\n//\t\t\t\t\t\t\tFixed rage damage formula again...\n//\t\t\t\t\t\t\tAdded basic support for non-strength Based barbarians (Dex, Hexblade)\n//\t\t\t\t\t\t\tAdded optional ability to toggle the icon and name of the macro itself based on current raging state.\n//\t\t\t\t\t\t4.\t(2020/06/04) \n//\t\t\t\t\t\t\tFixed bug with experimental macro name/icon toggle only by renaming \"actor\" and \"token\"\n//\t\t\t\t\t\t\tAdded basic localization support to allow searching for translated class features\n//\t\t\t\t\t\t5.\t(2020/06/10)\n//\t\t\t\t\t\t\tRework to rage damage logic under the hood for edge case (other changes to bonus damage mid-combat) \n//\t\t\t\t\t\t\tRemoved logic that was causing multiple character sheets to open in some cases\n//\t\t\t\t\t\t\tEnhanced localization support\n\n//!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n//!!!   Bonus Tip 1: \t\tOptional Rage Resource Consumption\n//!!!\tTo automatically use and track Rage, you must have a resource exactly named \"Rage\" on your character sheet. This text can be changed\n//!!!\tby altering the value for \"rageResourceName\" in the LOCALIZATION SUPPORT section below).\n//!!!\tNote: \tImporting via VTTA Beyond Integration uses this text already. The macro can then automatically detect the Rage resource.\n//!!!\n//!!!\tBonus Tip 2: \t\tBear Totem Spirit Barbs\n//!!!\tIf you chose the Spirit Seeker Primal path, and at level 3 you chose the Bear Totem Spirit (resistance to all non-psychic damage), \n//!!!\tin your 5E character sheet, double-check that the name of your Totem Spirit feature to EXACTLY \"Totem Spirit: Bear\". This text can be\n//!!!\tchanged by altering the value for \"bearTotemFeatureName\" in the LOCALIZATION SUPPORT section below).\n//!!!\tNote: \tImporting via VTTA Beyond Integration uses this text already. The macro then automatically adds the extra \n//!!!\t\t\tBear Totem Spirit resistances.\n//!!!\n//!!!\tBonus Tip 3: \t\tThrown Weapons\n//!!!\tWhen a barb throws a weapon using strength, typically a javelin but also possibly a dagger, dart, sword, bar table etc, the rage bonus\n//!!!\tshould not be added because it is a ranged attack. However, D&D5E calls javelins and daggers Melee Weapons, because technically they\n//!!!\tare both. To solve this issue, if you always throw the weapon, click the weapon's details and change the attack type to \"Ranged Weapon\n//!!!\tAttack\" in the Action Type dropdown. If you want, you can add a second copy of the item (with no weight/quantity) to use for meleeing.\n//!!!\n//!!!\tBonus Tip 4: \t\tThe Rage Condition\n//!!!\tIf you use the Combat Utility Belt module's Condition Lab, try adding a condition called \"Raging\" with the same icon\n//!!!\tas the optional rage icon overlay, 'icons/svg/explosion.svg' by default.  See EXPERIMENTAL MACRO ICON/NAME TOGGLE section below.\n//!!!\n//!!!\tBonus Tip 5: \t\tObsidian Sheet Compatibility\n//!!!\tIf using Obsidian module, try replacing \"Barbarian\" with \"brb\" as the barbClassName value in LOCALIZATION SUPPORT below.\n//!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n\n//!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n//!!!\tOPTIONAL TOKEN ICON-\tOn by default. If a path to a rage icon is defined, it displays like a condition on the raging barbarian.\n//!!!\t\t\t\t\t\t\tTo use a different icon, manually change the filepath below or leave it empty ('') to disable the effect.\n//!!!\nconst rageIconPath = 'icons/svg/explosion.svg';\n//!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n\n//!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n//!!!\tOPTIONAL RESOURCE DEDUCTION \tOn by default. First option automatically subtracts from the Rage Resource if enabled.\n//!!!\t\t\t\t\t\t\t\t\tSecond option prevents raging if no Rage resource is left. Set to false if you do not want this.\n\n\t\t\tconst deductResource = true;\n\t\t\tconst preventNegativeResource = true;\n//!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n\n//!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n//!!!\tOPTIONAL NON-STRENGTH BARBARIAN SUPPORT\t\tONLY override to FALSE if your barbarian does not use Strength to make melee attacks\n//!!!\t\t\t\t\t\t\t\t\t\t\t\tand therefore does not get the Rage bonus to melee weapon attack damage.\n//!!!\n\t\t\tconst strAttacks = true;\n//!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n\n//!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n//!!!\tEXPERIMENTAL MACRO ICON/NAME TOGGLE\t\tIf enabled, the macro icon and name toggles based on the barbarian's rage state.\n//!!!\t\t\t\t\t\t\t\t\t\t\tCAUTIONS: \t1. \tThis feature is off by default and is intended for ADVANCED USERS ONLY.\n//!!!\t\t\t\t\t\t\t\t\t\t\t\t\t\t2. \tRequires configuration using \"The Furnace\" module for a player to run!\n//!!!\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tThe GM needs to grant The Furnace's \"Run as GM\" permission for this macro.\n//!!!\t\t\t\t\t\t\t\t\t\t\t\t\t\t3. \tWorks best with only one barbarian using this feature at a time.\n\n\t\t\t//To auto-toggle the macro's icon/name, override toggleMacro to true below.\n\t\t\tconst toggleMacro = false;\n\n\t\t\t//To use a different icon, manually change the filepath here\n\t\t\tconst stopRageIconPath = 'icons/svg/unconscious.svg';\n\n\t\t\t//You must update the following constant to this macro's exact name for the macro icon toggling to work.\n\t\t\tconst rageMacroName = 'Rage';\n//!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n\n//declarations\nlet barb = '';\nlet chatMsg = '';\nlet bear = '';\nlet noRage = false;\nlet rageDmgAdded = false;\nlet toggleResult = false;\nlet macroActor = actor;\nlet macroToken = token;\n\n//!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n//!!!\tLOCALIZATION SUPPORT\t\t\t\tSets names of D&D5E features as constants instead of hardcoding to allow easier translation.\n//!!!\t\t\t\t\t\t\t\t\t\tSets error messages and flavor text as constants also for easier translation.\n//!!!\n\t\t\t//MUST MATCH VALUES IN CHARACTER SHEET (if present)\n\t\t\tconst barbClassName = 'Barbarian';\n\t\t\tconst rageResourceName = 'Rage';\n\t\t\tconst bearTotemFeatureName = 'Totem Spirit: Bear';\n\n\t\t\t//All remaining values may be changed freely\n\n\t\t\t//Rage chat message flavor text. Actor's name appears immediately before these two strings in the message.\n\t\t\tconst rageMsg = ' is RAAAAAGING!'\n\t\t\tconst endRageMsg =  ' is no longer raging.';\n\n\t\t\t//error and warning messages\n\t\t\tconst errorSelectBarbarian = 'Please select a single barbarian token.';\n\t\t\tconst errorNoRage = ' does not have any rage left, time for a long rest!';\n\t\t\tconst warnMacroNotFound = ' is not a valid macro name, please fix. Rage toggle successful but unable to alter macro.';\n\t\t\tconst errorSelectToken = 'Please select a token.';\n\t\t\tconst errorFailRevert = 'Failed to revert global melee weapon attack bonus, please check manually.';\n//!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n\n\n//main\n//check to see if Actor exists and is a barbarian\nif (macroActor !== undefined && macroActor !== null) {\n\n\t// get the barbarian class item\n\tbarb = macroActor.items.find(i => i.name === `${barbClassName}`);\n\tif (barb == undefined) {\n\t\tui.notifications.warn(`${errorSelectBarbarian}`);\n\t}\n\tif (barb !== undefined && barb !== null) {\n\t\tchatMsg = `${macroActor.name} + rageMsg`;\n\t\tlet enabled = false;\n\t\t// Store the state of the rage toggle flags that indicate if rage is active or not\n\t\tif (macroActor.data.flags.rageMacro !== null && macroActor.data.flags.rageMacro !== undefined) {\n\t\t\tenabled = true;\n\t\t\t\t// Store whether there is also a rage damage bonus currently active\n\t\t\t\tif (macroActor.data.flags.rageMacro[\"rageDmgAdded\"] == true) {\n\t\t\t\t\trageDmgAdded = true;\n\t\t\t\t}\n\t\t}\n\n\t\t//Calculate rage value for use in damage reversion and application\n\t\t// Determining the barbarian level\n\t\tlet barblvl = barb.data.data.levels;\n\n\t\t// Formula to determine the rage bonus damage depending on barbarian level\n\t\tlet lvlCorrection =  barblvl === 16 || barblvl === 17 ? 1 : 0;\n\t\tlet rageDmg = 2 + Math.floor(barblvl / 9) + lvlCorrection;\n\t\tlet dmg = JSON.parse(JSON.stringify(macroActor.data.data.bonuses.mwak.damage));\n\n\t\t// if rage is active, disable it\n\t\tif (enabled) {\n\t\t\tchatMsg = `${macroActor.name} ${endRageMsg}`;\n\t\t\t// reset resistances and melee weapon attack bonus\n\t\t\tlet obj = {};\n\t\t\tobj['flags.rageMacro'] = null;\n\t\t\t//revert damage resistances\n\t\t\tobj['data.traits.dr'] = macroActor.data.flags.rageMacro.oldResistances;\n\n\t\t\t//carefully revert rage global mwak damage bonus to original value, if that bonus is active\n\t\t\t//eventually want to add support so only last instance found is replaced.\n\t\t\tif(rageDmgAdded) {\n\t\t\t\tif (dmg == rageDmg || dmg == null || dmg == undefined || dmg == '' || dmg == 0){\n\t\t\t\t\tconsole.log('Removing simple rage damage');\n\t\t\t\t\tobj['data.bonuses.mwak.damage']='';\n\t\t\t\t} else {\n\t\t\t\t\tconsole.log('Removing complex rage damage');\n\t\t\t\t\tlet patt = `\\\\s\\\\+\\\\s${rageDmg}($|[^0123456789dkrxcm(@{])`;\n\t\t\t\t\tlet result = dmg.search(patt);\n\t\t\t\t\tif (result !== -1) {\n\t\t\t\t\t\tlet len = ('' + rageDmg).length;\n\t\t\t\t\t\tlet origDmg = duplicate(dmg);\n\t\t\t\t\t\tlet firstHalfDmg = duplicate(dmg).substring(0,result);\n\t\t\t\t\t\t//Test String: 2d6 + 2 + 2d6\n\t\t\t\t\t\tlet lastHalfDmg = duplicate(dmg).substring(result+3+len, origDmg.length);\n\t\t\t\t\t\tdmg = `${firstHalfDmg}${lastHalfDmg}`;\n\t\t\t\t\t\tobj['data.bonuses.mwak.damage']=dmg;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tui.notifications.error(`${errorFailRevert}`);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tmacroActor.update(obj);\n\n\t\t// if rage is disabled, enable it\n\t\t} else {\n\t\t\tif (deductResource) {\n\t\t\t\tlet hasAvailableResource = false;\n\t\t\t\tlet newResources = duplicate(macroActor.data.data.resources)\n\t\t\t\tlet obj = {}\n\t\t\t\t// Look for Resources under the Core macroActor data\n\t\t\t\tlet resourceKey = Object.keys(macroActor.data.data.resources).filter(k => macroActor.data.data.resources[k].label === `${rageResourceName}`).shift();\n\t\t\t\tif (resourceKey && (macroActor.data.data.resources[resourceKey].value > 0 || !preventNegativeResource)) {\n\t\t\t\t\thasAvailableResource = true;\n\t\t\t\t\tnewResources[resourceKey].value--;\n\t\t\t\t\tobj['data.resources'] = newResources \n\t\t\t\t\tmacroActor.update(obj);\n\t\t\t\t}\n\t\t\t\tif (!hasAvailableResource) {\n\t\t\t\t\tui.notifications.error(`${macroActor.name} ${errorNoRage}`);\n\t\t\t\t\tnoRage=true;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t//activate rage if there is rage available, or if it is okay to rage with 0 resources\n\t\t\tif (!noRage) {\n\t\t\t\tchatMsg = `${macroActor.name} ${rageMsg}`;\n\t\t\t\t// update resistance\n\t\t\t\tlet obj = {};\n\t\t\t\t// storing old resistances in flags to restore later\n\t\t\t\tobj['flags.rageMacro.enabled'] = true;\n\t\t\t\tobj['flags.rageMacro.oldResistances'] = JSON.parse(JSON.stringify(macroActor.data.data.traits.dr));\n\t\t\t\t// add bludgeoning, piercing and slashing resistance\n\t\t\t\tlet newResistance = duplicate(macroActor.data.data.traits.dr);\n\t\t\t\tif (newResistance.value.indexOf('bludgeoning') === -1) newResistance.value.push('bludgeoning');\n\t\t\t\tif (newResistance.value.indexOf('piercing') === -1) newResistance.value.push('piercing');\n\t\t\t\tif (newResistance.value.indexOf('slashing') === -1) newResistance.value.push('slashing');\n\t\t\t\t//If bear totem, add bear totem resistances.\n\t\t\t\tbear = macroActor.items.find(i => i.name === `${bearTotemFeatureName}`)\n\t\t\t\tif (bear !== undefined && bear!== null) {\n\t\t\t\t\tif (newResistance.value.indexOf('acid') === -1) newResistance.value.push('acid');\n\t\t\t\t\tif (newResistance.value.indexOf('cold') === -1) newResistance.value.push('cold');\n\t\t\t\t\tif (newResistance.value.indexOf('fire') === -1) newResistance.value.push('fire');\n\t\t\t\t\tif (newResistance.value.indexOf('force') === -1) newResistance.value.push('force');\n\t\t\t\t\tif (newResistance.value.indexOf('lightning') === -1) newResistance.value.push('lightning');\n\t\t\t\t\tif (newResistance.value.indexOf('necrotic') === -1) newResistance.value.push('necrotic');\n\t\t\t\t\tif (newResistance.value.indexOf('poison') === -1) newResistance.value.push('poison');\n\t\t\t\t\tif (newResistance.value.indexOf('radiant') === -1) newResistance.value.push('radiant');\n\t\t\t\t\tif (newResistance.value.indexOf('thunder') === -1) newResistance.value.push('thunder');\n\t\t\t\t}\n\t\t\t\tobj['data.traits.dr'] = newResistance;\n\t\t\t\tmacroActor.update(obj);\n\n\t\t\t\t// For Strength barbarians, update global melee weapon attack bonus to include rage bonus\n\t\t\t\tif (strAttacks) {\n\t\t\t\t\tobj['flags.rageMacro.rageDmgAdded'] = true;\n\t\t\t\t\t// Preserve old mwak damage bonus if there was one, just in case\n\t\t\t\t\tobj['flags.rageMacro.oldDmg'] = JSON.parse(JSON.stringify(dmg));\n\t\t\t\t\t//actually add the bonus rage damage to the previous bonus damage\n\t\t\t\t\t//respect roll formulas by doing string addition if value is already present.\n\t\t\t\t\tif (dmg == null || dmg == undefined || dmg == 0 || dmg == '') {\n\t\t\t\t\t\tconsole.log('Adding simple rage damage');\n\t\t\t\t\t\tobj['data.bonuses.mwak.damage'] = rageDmg;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tconsole.log('Adding complex rage damage');\n\t\t\t\t\t\tobj['data.bonuses.mwak.damage'] = `${dmg} + ${rageDmg}`;\n\t\t\t\t\t}\n\t\t\t\t\tmacroActor.update(obj);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (!noRage) {\n\t\t\t// toggle rage icon, if rage path is defined above\n\t\t\t(async () => { \n\t\t\t\ttoggleResult = await macroToken.toggleEffect(rageIconPath);\n\t\t\t\tif (toggleResult == enabled) macroToken.toggleEffect(rageIconPath);  \n\t\t\t})();\n\t\t\t\n\t\t\t//toggle macro icon and name, if macro name is correct and stop rage icon path is defined\n\t\t\tlet rageMacro = game.macros.getName(rageMacroName);\n\t\t\t\t//check for name of macro in its \"off\" form\n\t\t\t\tif (rageMacro == null || rageMacro == undefined) {\n\t\t\t\t\trageMacro = game.macros.getName('Stop ' + rageMacroName);\n\t\t\t\t}\n\t\t\tlet obj = {};\n\t\t\tif ( (rageMacro !== null && rageMacro !== undefined) && toggleMacro == true && \n\t\t\t\t\t+ (stopRageIconPath !== null && stopRageIconPath !== undefined && stopRageIconPath !== '') ) {\n\t\t\t\tif (enabled) {\n\t\t\t\t  obj['img'] = rageIconPath;\n\t\t\t\t  obj['name'] = rageMacroName;\n\t\t\t\t} else {\n\t\t\t\t  obj['img'] = stopRageIconPath;\n\t\t\t\t  obj['name'] = 'Stop ' + rageMacroName;\n\t\t\t\t}\n\t\t\t\trageMacro.update(obj);\n\t\t\t} else {\n\t\t\tif (toggleMacro == true) ui.notifications.warn(`${rageMacroName} ${warnMacroNotFound}`);\n\t\t\t}\n\t\t}\n\t}\n} else ui.notifications.warn(errorSelectToken);\n// write to chat if needed:\nif (chatMsg !== '') {\n\tlet chatData = {\n\t\tuser: game.user._id,\n\t\tspeaker: ChatMessage.getSpeaker(),\n\t\tcontent: chatMsg\n\t};\n\tChatMessage.create(chatData, {});\n}\n\nif (token)\n  MacroMarker.toggle(this, { entity: token });","author":"NeG597KOgANJAOdY","img":"systems/dnd5e/icons/skills/red_10.jpg","actorIds":[],"_id":"kAp6csv45RW5JtlA"}
{"name":"Sharpshooter--Liga/Desliga","permission":{"default":0,"NeG597KOgANJAOdY":3},"type":"script","flags":{"macro-marker":{"activeData":{"icon":"systems/dnd5e/icons/skills/green_01.jpg","tooltip":"Sharpshooter-Macro","colour":"#51b819","trigger":""}},"combat-utility-belt":{"macroTrigger":""},"core":{"sourceId":"Macro.st5uamdtz1mivXIx"},"furnace":{"runAsGM":false}},"scope":"global","command":"/*\nCreated Monkan#8752 with guidance from the Rage macro in the FVTT Community Macros\n\nTips to make it work\n 1 -    Have a feature called 'Sharpshooter' for your character.\n 2 -    Make sure you have your weapons with Ranged Weapon Attack. \n 3 -    if you make any changes to your damage or attack calculations, make sure you toggle it off.\n        As it stores the old values to replace once you disable the feat.  It could undo your changes.\n*/\n\nlet ss='';\nlet chatMsg='';\n\n\nif (actor !== undefined && actor !== null) {\n    // find the feat Sharpshooter\n    ss = actor.items.find(i => i.name === 'Sharpshooter');\n    if (ss == undefined) { \n        ui.notifications.warn(\"Please select a single token with the Sharpshooter feat.\");        \n    }\n\n    if (ss !== undefined && ss !== null) {\n\t\tchatMsg = '';\n\t\tlet enabled = false;\n\t\t// store the state of the Sharpshooter toggle in flags\n\t\tif (actor.data.flags.ssMacro !== null && actor.data.flags.ssMacro !== undefined) {\n\t\t\tenabled = true;\n\t\t}\n\t\t// if Sharpshooter is active, disable it\n\t\tif (enabled) {\n            chatMsg = `${actor.name} Sharpshooter Ligado.`;\n            \n            let obj = {};\n\t\t\tobj['flags.ssMacro'] = null;\t\t\t\n\t\t\tactor.update(obj);\n\n\t\t\t// reset items\n\t\t\tfor (let item of actor.items) {\n\t\t\t\tif (item.data.flags.ssMacro !== null && item.data.flags.ssMacro !== undefined) {\n\t\t\t\t\t// restoring the old value from flags\n                    let oldDmg = item.data.flags.ssMacro.oldDmg;\n                    let oldAtk = item.data.flags.ssMacro.oldAtk;\n\t\t\t\t\tlet obj = {};\n                    obj['data.damage.parts'] = oldDmg;\n                    obj['data.attackBonus'] = oldAtk;\n\t\t\t\t\tobj['flags.ssMacro'] = null;\n\t\t\t\t\titem.update(obj);\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t// if Sharpshooter is disabled, enable it\n\t\t} else {\n            chatMsg = `${actor.name} Sharpshooter desligado!!`;\n            \n            let obj = {};\n\t\t\tobj['flags.ssMacro.enabled'] = true;\n\t\t\tactor.update(obj);\n\n            // update items\n            let ssAtk = -5;\n\t\t\tlet ssDmg = 10;\n\t\t\tfor (let item of actor.items) {\n                let isRanged = getProperty(item, 'data.data.actionType') === 'rwak';                \n\t\t\t\tif (isRanged && item.data.data.damage.parts.length > 0) {\n\t\t\t\t\tconsole.log('updating ' + item);\n                    let obj = {};\n                    let atk = item.data.data.attackBonus;\n                    let dmg = item.data.data.damage.parts;\n                    // Save old attack and damage values\n                    obj['flags.ssMacro.oldDmg'] = JSON.parse(JSON.stringify(dmg));\n                    obj['flags.ssMacro.oldAtk'] = JSON.parse(JSON.stringify(atk));\n                    // Set the new attack and damage values\n                    if (atk !== null) {\n                        atk += '' + ssAtk;\n                    } else {\n                        atk = ssAtk;\n                    }\n\t\t\t\t\tdmg[0][0] = `${dmg[0][0]} + ${ssDmg}`;\n                    obj['data.damage.parts'] = dmg;\n                    obj['data.attackBonus'] = atk;\n\t\t\t\t\titem.update(obj);\n\t\t\t\t}\n\t\t\t}\n\n\t\t}\n    }\n\n} else ui.notifications.warn(\"Please select a token.\");\n\n// write to chat if needed:\nif (chatMsg !== '') {\n\tlet chatData = {\n\t\tuser: game.user._id,\n\t\tspeaker: ChatMessage.getSpeaker(),\n\t\tcontent: chatMsg\n    };\n\tChatMessage.create(chatData, {});\n}\n\nif (token)\n  MacroMarker.toggle(this, { entity: token });","author":"NeG597KOgANJAOdY","img":"systems/dnd5e/icons/skills/green_01.jpg","actorIds":[],"_id":"oXaCsZvvQswZ6r2V"}
{"name":"Sorcerer point macro","permission":{"default":0,"NeG597KOgANJAOdY":3},"type":"script","flags":{"macro-marker":{"activeData":{"icon":"icons/svg/dice-target.svg","tooltip":"New Macro","colour":"#ff0000","trigger":""}},"combat-utility-belt":{"macroTrigger":""},"furnace":{"runAsGM":false},"core":{"sourceId":"Macro.HzNg1DHlWywQVj0G"}},"scope":"global","command":"/*sorcerer point macro\n *Module Requirements : Furnace\n *Character Requirements : \tMust be a user with levels in \"Sorcerer\".\n *\t\t\t\tMust have a feature with uses equal to sorcerer level named \"Sorcery Points\"\n *\t\t\t\tMetamagic Feats must be named as they are in the Macro.\n */\nlet outlog =(...args) => console.log(\"Sorcerer | \", ...args);\nlet debug = false;\n//error checking\nif(game.user.character === null) return ui.notifications.warn(`Go away GM you are drunk.`);\nif(game.user.character.data.items.find(i=>i.name===\"Sorcerer\")===undefined) return ui.notifications.warn(`Your character does not have a Sorcerer Class.`);\n//variable creation\nlet s_actor = game.user.character;\nlet s_class = s_actor.data.items.find(i=>i.name===\"Sorcerer\");\nlet s_points = s_actor.data.items.find(i=>i.name===\"Sorcery Points\");\nlet s_slots = s_actor.data.data.spells;\nlet confirmed = false;\n\n//dialog\nSorcerer_Dialog();\n\n//functions\nfunction Sorcerer_Dialog()\n{\n\tif(s_class.data.levels > 1 && s_class.data.levels !== s_points.data.uses.max) return ui.notifications.warn(`Sorcery Points value is incorrect.`);\n\tlet content = `\n\t\t<div class = \"form-group\">\n\t\t\t<br>\n\t\t\t<label>Select Action  : </label>\n\t\t\t<select id=\"use\" name=\"use\">`;\n\tif(checkSlots(\"available\") && s_points.data.uses.value !== s_points.data.uses.max) {content += `<option value = \"sorcPoint\">Spell Slot => Sorcery Point</option>`;}\n\tif(checkSlots(\"missing\") && s_points.data.uses.value >= 2){content += `<option value = \"spellSlot\">Sorcery Point => Spell Slot</option>`;}\n\tif(checkPoints() > 0 && checkSlots(\"available\"))\n\t{\n\n\t\tif(game.user.character.data.items.find(i=>i.name===\"Metamagic: Careful Spell\")!==undefined)\n                      {content += `<option value = \"careful\">Careful Spell Spell</option>`;}\n                if(game.user.character.data.items.find(i=>i.name===\"Metamagic: Distant Spell\")!==undefined)\n                      {content += `<option value = \"distant\">Distant Spell</option>`;}\n                if(game.user.character.data.items.find(i=>i.name===\"Metamagic: Empowered Spell\")!==undefined)\n                      {content += `<option value = \"empower\">Empowered Spell</option>`;}\n                if(game.user.character.data.items.find(i=>i.name===\"Metamagic: Extended Spell\")!==undefined)\n                      {content += `<option value = \"extend\">Extended Spell</option>`;}\n                if(game.user.character.data.items.find(i=>i.name===\"Metamagic: Heightened Spell\")!==undefined)\n                      {content += `<option value = \"heighten\">Heightened Spell</option>`;}\n                if(game.user.character.data.items.find(i=>i.name===\"Metamagic: Quickened Spell\")!==undefined)\n                      {content += `<option value = \"quicken\">Quickened Spell</option>`;}\n                if(game.user.character.data.items.find(i=>i.name===\"Metamagic: Subtle Spell\")!==undefined)\n                      {content += `<option value = \"subtle\">Subtle Spell</option>`;}\n\t\tif(game.user.character.data.items.find(i=>i.name===\"Metamagic: Twinned Spell\")!==undefined)\n                      {content += `<option value = \"twin\">Twinned Spell</option>`;}\n\t}\n\tcontent += `</select><br><br></div>`;\n\n\tnew Dialog({\n\t\ttitle : \"Sorcery Points Spender\",\n\t\tcontent : content,\n\t\tbuttons : {\n\t\t\tone : {\n\t\t\t\ticon :`<i class=\"fas fa-check\"></i>`,\n\t\t\t\tlable : \"Continue\",\n\t\t\t\tcallback : () => confirmed = true\n\t\t\t},\n\t\t\ttwo : {\n\t\t\t\ticon : `<i class=\"fas fa-times\"></i>`,\n\t\t\t\tlable : \"Cancel\",\n\t\t\t\tcallback : () => confirmed = false\n\t\t\t}\n\t\t},\n\t\tdefault : \"Cancel\",\n\t\tclose : html => {\n\t\t\tif(confirmed){\n\t\t\t\tswitch(html.find('[name=use]')[0].value){\n\t\t\t\t\tcase \"sorcPoint\" :\n\t\t\t\t\t\tspell_SorceryPoints();\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase \"spellSlot\" :\n\t\t\t\t\t\tsorceryPoints_spell();\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase \"careful\" :\n\t\t\t\t\t\tmetaMagic_Careful();\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase \"distant\" :\n\t\t\t\t\t\tmetaMagic_Distant();\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase \"empower\" :\n\t\t\t\t\t\tmetaMagic_Empowered();\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase \"extend\" :\n\t\t\t\t\t\tmetaMagic_Extended();\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase \"heighten\" :\n\t\t\t\t\t\tmetaMagic_Heightened();\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase \"quicken\" :\n\t\t\t\t\t\tmetaMagic_Quickened();\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase \"subtle\" :\n\t\t\t\t\t\tmetaMagic_Subtle();\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase \"twin\" :\n\t\t\t\t\t\tmetaMagic_Twinned();\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}).render(true);\n}\nfunction spell_SorceryPoints()\n{\n\t//variable creation\n\tconfirmed = false;\n\tlet newContent = `<div class = \"form-group\">\n\t\t\t\t\t\t<br>\n\t\t\t\t\t\t<label>Select Level  : </label>\n\t\t\t\t\t\t<select id=\"lvl\" name=\"lvl\">`;\n\tfor(let slot in s_slots)\n\t{\n\t\tif(s_slots[slot].value !== 0 && s_slots[slot].value !== undefined)\n\t\t{\n\t\t\tnewContent += `<option value = \"${slot}\">Spell Slot Level ${slot.charAt(5)} (${s_slots[slot].value} currently)</option>`;\n\t\t}\n\t}\n\tnewContent += `</select></div>`;\n\t//Dialog and Logic\n\tnew Dialog({\n\t\ttitle : \"Creating Sorcery Points\",\n\t\tcontent : newContent,\n\t\tbuttons : {\n\t\t\tone : {\n\t\t\t\ticon :`<i class=\"fas fa-check\"></i>`,\n\t\t\t\tlable : \"Continue\",\n\t\t\t\tcallback : () => confirmed = true\n\t\t\t},\n\t\t\ttwo : {\n\t\t\t\ticon : `<i class=\"fas fa-times\"></i>`,\n\t\t\t\tlable : \"Cancel\",\n\t\t\t\tcallback : () => confirmed = false\n\t\t\t}\n\t\t},\n\t\tdefault : \"Cancel\",\n\t\tclose : html => {\n\t\t\tif(confirmed)\n\t\t\t{\n\t\t\t\t//variable creation\n\t\t\t\tlet lvlchosen = html.find('[name=lvl]')[0].value;\n\t\t\t\tlet actorUpdateData = duplicate(s_actor);\n\t\t\t\tlet itemUpdateData = duplicate(s_points);\n\t\t\t\t//This is where you would want to check for validity of use, maybe even a dialog to stop if unnecessary.\n\t\t\t\tactorUpdateData.data.spells[lvlchosen].value -= 1;\n\t\t\t\titemUpdateData.data.uses.value += Math.clamped(parseInt(lvlchosen.charAt(5)),0,itemUpdateData.data.uses.max);\n\t\t\t\t//character and item update\n\t\t\t\ts_actor.update(actorUpdateData);\n\t\t\t\ts_actor.updateEmbeddedEntity(\"OwnedItem\", itemUpdateData);\n\t\t\t\t//Display Information\n\t\t\t\tdisplay(`Succesfully Used a : Level ${lvlchosen.charAt(5)} Spell Slot <br> Creating : ${lvlchosen.charAt(5)} sorcery points.`);\n\t\t\t}\n\t\t}\n\t}).render(true);\n}\nfunction sorceryPoints_spell()\n{\n\t//variable creation\n\tconfirmed = false;\n\tlet s_cost = [2,3,5,6,7];\n\tlet newContent = `<div class = \"form-group\">\n\t\t\t\t\t\t<br>\n\t\t\t\t\t\t<label>Select Level  : </label>\n\t\t\t\t\t\t<select id=\"lvl\" name=\"lvl\">`;\n\tfor(let slot in s_slots)\n\t{\n\t\tif(parseInt(slot.charAt(5)) <= Math.ceil(s_class.data.levels/2) && parseInt(slot.charAt(5)) < 6)\n\t\t{\n\t\t\tif(s_points.data.uses.value >= s_cost[parseInt(slot.charAt(5)-1)] && s_slots[slot].value !== s_slots[slot].max)\n\t\t\t{\n\t\t\t\tnewContent += `<option value=\"${slot}\">Spell Slot Level ${slot.charAt(5)} (${s_slots[slot].value} currently)</option>`;\n\t\t\t}\n\t\t}\n\t}\n\tnewContent += `</select></div>`;\n\tnew Dialog({\n\t\ttitle : \"Creating Spell Slots\",\n\t\tcontent : newContent,\n\t\tbuttons : {\n\t\t\tone : {\n\t\t\t\ticon :`<i class=\"fas fa-check\"></i>`,\n\t\t\t\tlable : \"Continue\",\n\t\t\t\tcallback : () => confirmed = true\n\t\t\t},\n\t\t\ttwo : {\n\t\t\t\ticon : `<i class=\"fas fa-times\"></i>`,\n\t\t\t\tlable : \"Cancel\",\n\t\t\t\tcallback : () => confirmed = false\n\t\t\t}\n\t\t},\n\t\tdefault : \"Cancel\",\n\t\tclose : html => {\n\t\t\tif (confirmed){\n\t\t\t\tlet lvlchosen = html.find('[name=lvl]')[0].value;\n\t\t\t\tlet actorUpdateData = duplicate(s_actor);\n\t\t\t\tlet itemUpdateData = duplicate(s_points);\n\t\t\t\tactorUpdateData.data.spells[lvlchosen].value += 1;\n\t\t\t\titemUpdateData.data.uses.value -= Math.clamped((s_cost[parseInt(lvlchosen.charAt(5)-1)]),0,itemUpdateData.data.uses.max);\n\t\t\t\ts_actor.update(actorUpdateData);\n\t\t\t\ts_actor.updateEmbeddedEntity(\"OwnedItem\", itemUpdateData);\n\t\t\t\tdisplay(`Succesfully Used : ${s_cost[parseInt(lvlchosen.charAt(5)-1)]} sorcery points. <br> Creating : Spell Slot Level ${lvlchosen.charAt(5)}`);\n\t\t\t}\n\t\t}\n\t}).render(true);\n}\nfunction metaMagic_Careful()\n{\n\tif(game.user.character.data.items.find(i=>i.name===\"Metamagic: Careful Spell\")===undefined) return ui.notifications.warn(`Your character does not have a Metamagic: Careful Spell.`);\n\tgame.dnd5e.rollItemMacro(\"Metamagic: Careful Spell\").then(()=> {\n\t\tlet itemUpdateData = duplicate(s_points);\n\t\titemUpdateData.data.uses.value -= 1;\n\t\ts_actor.updateEmbeddedEntity(\"OwnedItem\", itemUpdateData);\n\t});\n\n}\nfunction metaMagic_Distant()\n{\n\tif(game.user.character.data.items.find(i=>i.name===\"Metamagic: Distant Spell\")===undefined) return ui.notifications.warn(`Your character does not have a Metamagic: Distant Spell.`);\n\tgame.dnd5e.rollItemMacro(\"Metamagic: Distant Spell\").then(()=> {\n\t\tlet itemUpdateData = duplicate(s_points);\n\t\titemUpdateData.data.uses.value -= 1;\n\t\ts_actor.updateEmbeddedEntity(\"OwnedItem\", itemUpdateData);\n\t});\n\n}\nfunction metaMagic_Empowered()\n{\n\tif(game.user.character.data.items.find(i=>i.name===\"Metamagic: Empowered Spell\")===undefined) return ui.notifications.warn(`Your character does not have a Metamagic: Empowered Spell.`);\n\tgame.dnd5e.rollItemMacro(\"Metamagic: Empowered Spell\").then(()=> {\n\t\tlet itemUpdateData = duplicate(s_points);\n\t\titemUpdateData.data.uses.value -= 1;\n\t\ts_actor.updateEmbeddedEntity(\"OwnedItem\", itemUpdateData);\n\t});\n\n}\nfunction metaMagic_Extended()\n{\n\tif(game.user.character.data.items.find(i=>i.name===\"Metamagic: Extended Spell\")===undefined) return ui.notifications.warn(`Your character does not have a Metamagic: Extended Spell.`);\n\tgame.dnd5e.rollItemMacro(\"Metamagic: Extended Spell\").then(()=> {\n\t\tlet itemUpdateData = duplicate(s_points);\n\t\titemUpdateData.data.uses.value -= 1;\n\t\ts_actor.updateEmbeddedEntity(\"OwnedItem\", itemUpdateData);\n\t});\n\n}\nfunction metaMagic_Heightened()\n{\n\tif(game.user.character.data.items.find(i=>i.name===\"Metamagic: Heightened Spell\")===undefined) return ui.notifications.warn(`Your character does not have a Metamagic: Heightened Spell.`);\n\tgame.dnd5e.rollItemMacro(\"Metamagic: Heightened Spell\").then(()=> {\n\t\tlet itemUpdateData = duplicate(s_points);\n\t\titemUpdateData.data.uses.value -= 3;\n\t\ts_actor.updateEmbeddedEntity(\"OwnedItem\", itemUpdateData);\n\t});\n\n}\nfunction metaMagic_Quickened()\n{\n\tif(game.user.character.data.items.find(i=>i.name===\"Metamagic: Quickened Spell\")===undefined) return ui.notifications.warn(`Your character does not have a Metamagic: Quickened Spell.`);\n\tgame.dnd5e.rollItemMacro(\"Metamagic: Quickened Spell\").then(()=> {\n\t\tlet itemUpdateData = duplicate(s_points);\n\t\titemUpdateData.data.uses.value -= 2;\n\t\ts_actor.updateEmbeddedEntity(\"OwnedItem\", itemUpdateData);\n\t});\n\n}\nfunction metaMagic_Subtle()\n{\n\tif(game.user.character.data.items.find(i=>i.name===\"Metamagic: Subtle Spell\")===undefined) return ui.notifications.warn(`Your character does not have a Metamagic: Subtle Spell.`);\n\tgame.dnd5e.rollItemMacro(\"Metamagic: Subtle Spell\").then(()=> {\n\t\tlet itemUpdateData = duplicate(s_points);\n\t\titemUpdateData.data.uses.value -= 1;\n\t\ts_actor.updateEmbeddedEntity(\"OwnedItem\", itemUpdateData);\n\t});\n\n}\nfunction metaMagic_Twinned()\n{\n\tif(game.user.character.data.items.find(i=>i.name===\"Metamagic: Twinned Spell\")===undefined) return ui.notifications.warn(`Your character does not have a Metamagic: Twinned Spell.`);\n\tconfirmed = false;\n\tlet newContent = `<div class = \"form-group\">\n\t<br>\n\t<label>Select Level  : </label>\n\t<select id=\"lvl\" name=\"lvl\">`;\n\tfor(let slot in s_slots)\n\t{\n\t\tif(parseInt(slot.charAt(5)) <= s_points.data.uses.value)\n\t\t{\n\t\t\tnewContent += `<option value=\"${slot}\">Spell Slot Level ${slot.charAt(5)} - ${s_slots[slot].value}</option>`;\n\t\t}\n\t}\n\tnewContent += `</select></div>`;\n\tnew Dialog({\n\t\ttitle : \"Twinned Spell\",\n\t\tcontent : newContent,\n\t\tbuttons : {\n\t\t\tone : {\n\t\t\t\ticon :`<i class=\"fas fa-check\"></i>`,\n\t\t\t\tlable : \"Continue\",\n\t\t\t\tcallback : () => confirmed = true\n\t\t\t},\n\t\t\ttwo : {\n\t\t\t\ticon : `<i class=\"fas fa-times\"></i>`,\n\t\t\t\tlable : \"Cancel\",\n\t\t\t\tcallback : () => confirmed = false\n\t\t\t}\n\t\t},\n\t\tdefault : \"Cancel\",\n\t\tclose : html => {\n\t\t\tif(confirmed)\n\t\t\t{\n\t\t\t\tgame.dnd5e.rollItemMacro(\"Metamagic: Twinned Spell\").then(()=>{\n\t\t\t\t\tlet lvlchosen = html.find('[name=lvl]')[0].value;\n\t\t\t\t\tlet itemUpdateData = duplicate(s_points);\n\t\t\t\t\titemUpdateData.data.uses.value -= parseInt(lvlchosen.charAt(5));\n\t\t\t\t\ts_actor.updateEmbeddedEntity(\"OwnedItem\", itemUpdateData);\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\t}).render(true);\n}\nfunction display(data =\"\"){\n\tif(data!==\"\")\n\t{\n\t\tChatMessage.create({\n\t\t\tuser : game.user._id,\n\t\t\tcontent : data,\n\t\t\tspeaker : speaker//, //GM whisper (to not make the chat window huge)\n\t\t\t//whisper : game.users.entities.filter(u=>u.isGM).map(u=>u._id)\n\t\t});\n\t}\n}\nfunction checkSlots(data = \"\")\n{\n\tif(data === \"available\")\n\t{\n\t\tfor(let slot in s_slots)\n\t\t{\n\t\t\tif(s_slots[slot].value > 0)\n\t\t\t{\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t}else if (data === \"missing\")\n\t{\n\t\tfor(let slot in s_slots)\n\t\t{\n\t\t\tif(s_slots[slot].value !== s_slots[slot].max)\n\t\t\t{\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t}\n\treturn false;\n}\nfunction checkPoints(){\n\treturn s_points.data.uses.value;\n}","author":"NeG597KOgANJAOdY","img":"systems/dnd5e/icons/skills/nature_07.jpg","actorIds":[],"_id":"sPpFljvy0z9PRPOd"}
{"name":"Divine Smite - Macro","permission":{"default":0,"NeG597KOgANJAOdY":3},"type":"script","flags":{"macro-marker":{"activeData":{"icon":"icons/svg/dice-target.svg","tooltip":"Divine Smite","colour":"#ff0000","trigger":""}},"combat-utility-belt":{"macroTrigger":""},"core":{"sourceId":"Macro.Sv9CNKuejk3BPdmp"}},"scope":"global","command":"/*\n * The Smite macro emulates the Divine Smite feature of Paladins in DnD 5e. A spell slot level to use\n * can be selected, which increases the number of damage dice, and smiting a fiend or undead\n * will also increase the number of damage dice.\n * \n * If a token is not selected, the macro will default back to the default character for the Actor. \n * This allows for the GM to cast the macro on behalf a character that possesses it, \n * without requiring that a PC have their character selected.\n * To execute the macro a target MUST be specified and, unless configured otherwise, the character must have an available spell slot. \n * Make your regular attack and then if you choose to use Divine Smite, run this macro.\n */\n\n//Configurable variables\nlet maxSpellSlot = 5; //  Highest spell-slot level that may be used.\nlet affectedCreatureTypes = [\"fiend\", \"undead\", \"undead (shapechanger)\"]; //  Creature types that take extra damage.\n\n// Use token selected, or default character for the Actor if none is.\nlet s_actor = canvas.tokens.controlled[0]?.actor || game.user.character;     \n\n// Verifies if the actor can smite.\nif (s_actor?.data.items.find(i => i.name === \"Divine Smite\") === undefined){\n    return ui.notifications.error(`No valid actor selected that can use this macro.`);\n}\n\nlet confirmed = false;\nif (hasAvailableSlot(s_actor)) {\n\n    // Get options for available slots\n    let optionsText = \"\";\n    for (let i = 1; i < maxSpellSlot; i++) {\n        let chosenSpellSlots = getSpellSlots(s_actor, i);\n        if (chosenSpellSlots.value > 0) {\n            optionsText += `<option value=\"${i}\">${i} - ${chosenSpellSlots.value} slots available</option>`;\n        }\n    }\n\t\n    // Create a dialogue box to select spell slot level to use when smiting.\n    new Dialog({\n        title: \"Divine Smite Damage\",\n        content: `\n        <form>\n        <p>Spell Slot level to use Divine Smite with.</p>\n            <div class=\"form-group\">\n                <label>Spell Slot Level:</label>\n                <select name=\"slot-level\">` + optionsText + `</select>\n            </div>\n            <div class=\"form-group\">\n                <label>Critical Hit:</label>\n                <input type=\"checkbox\" name=\"criticalCheckbox\">\n            </div>\n        </form>\n        `,\n        buttons: {\n            one: {\n                icon: '<i class=\"fas fa-check\"></i>',\n                label: \"SMITE!\",\n                callback: () => confirmed = true\n            },\n            two: {\n                icon: '<i class=\"fas fa-times\"></i>',\n                label: \"Cancel\",\n                callback: () => confirmed = false\n            }\n        },\n        default: \"Cancel\",\n        close: html => {\n            if (confirmed) {\n                let slotLevel = parseInt(html.find('[name=slot-level]')[0].value);\n                let criticalHit = html.find('[name=criticalCheckbox]')[0].checked;\n                smite(s_actor, slotLevel, criticalHit);\n            }\n        }\n    }).render(true);\n\n} else {\n    return ui.notifications.error(`No spell slots available to use this feature.`);    \n}\n\n/**\n * Gives the spell slot information for a particular actor and spell slot level.\n * @param {Actor5e} actor - the actor to get slot information from.\n * @param {integer} level - the spell slot level to get information about. level 0 is deprecated.\n * @returns {object} contains value (number of slots remaining), max, and override.\n */\nfunction getSpellSlots(actor, level) {\n    return actor.data.data.spells[`spell${level}`];\n}\n\n/**\n * Returns whether the actor has any spell slot left.\n * @param {Actor5e} actor - the actor to get slot information from.\n * @returns {boolean} True if any spell slots of any spell level are available to be used.\n */\n function hasAvailableSlot(actor) {\n     for (let slot in actor.data.data.spells) {\n         if (actor.data.data.spells[slot].value > 0) {\n             return true;\n         }\n     }\n     return false;\n }\n\n/**\n * Use the controlled token to smite the targeted token.\n * @param {Actor5e} actor - the actor that is performing the action.\n * @param {integer} slotLevel - the spell slot level to use when smiting.\n * @param {boolean} criticalHit - whether the hit is a critical hit.\n */\nfunction smite(actor, slotLevel, criticalHit) {\n    let targets = game.user.targets;\n    let chosenSpellSlots = getSpellSlots(actor, slotLevel);\n\n    if (chosenSpellSlots.value < 1) {\n        ui.notifications.error(\"No spell slots of the required level available.\");\n        return;\n    }\n    if (targets.size !== 1) {\n        ui.notifications.error(\"You must target exactly one token to Smite.\");\n        return;\n    }\n\n    targets.forEach(target => {\n        let numDice = slotLevel + 1;\n        let type = target.actor.data.data.details.type?.toLocaleLowerCase();\n        if (affectedCreatureTypes.includes(type)) numDice += 1;\n        if (criticalHit) numDice *= 2;\n        new Roll(`${numDice}d8`).roll().toMessage({ flavor: \"Macro Divine Smite - Damage Roll (Radiant)\", speaker })\n    })\n\n    let objUpdate = new Object();\n    objUpdate['data.spells.spell' + slotLevel + '.value'] = chosenSpellSlots.value - 1;\n    actor.update(objUpdate);\n}","author":"NeG597KOgANJAOdY","img":"systems/dnd5e/icons/skills/light_05.jpg","actorIds":[],"_id":"z3bNTTP83PLWJqtZ"}
{"name":"Paladin-Sacred_weapon","permission":{"default":0,"X2FU4EYTKyUpwF0o":3},"type":"chat","flags":{"macro-marker":{"activeData":{"icon":"icons/svg/dice-target.svg","tooltip":"New Macro","colour":"#ff0000","trigger":""}},"combat-utility-belt":{"macroTrigger":""},"furnace":{"runAsGM":false},"core":{"sourceId":"Macro.Hpp1xQ6oZg8AlnxB"}},"scope":"global","command":"let target = canvas.tokens.get(args[1]);\nlet targetActor = target.actor;\nlet weapons = targetActor.items.filter(i => i.data.type === `weapon`);\nlet weapon_content = ``;\nlet ActorSetFlag = game.macros.getName(\"ActorSetFlag\");\nlet ActorUnSetFlag = game.macros.getName(\"ActorUnSetFlag\");\nlet ActorGetFlag = game.macros.getName(\"ActorGetFlag\");\n\nfor (let weapon of weapons) {\n    weapon_content += `<option value=${weapon.id}>${weapon.name}</option>`;\n}\nif (args[0] === \"on\") {\n    let content = `\n<div class=\"form-group\">\n  <label>Weapons : </label>\n  <select name=\"weapons\">\n    ${weapon_content}\n  </select>\n</div>`;\n\n    new Dialog({\n        content,\n        buttons:\n        {\n            Ok:\n            {\n                label: `Ok`,\n                callback: (html) => {\n                    let itemId = html.find('[name=weapons]')[0].value;\n                    let item = targetActor.items.get(itemId);\n                    let copy_item = duplicate(item);\n                    let bonus = args[2];\n                    let wpAttack = copy_item.data.attackBonus\n                    let dimLight = target.data.dimLight;\n                    let brightLight = target.data.brightLight\n                    target.actor.setFlag(`world`, `sacredWeapon`, {\n                        bonus: bonus,\n                        weapon: itemId,\n                        weaponAttack: wpAttack,\n                        dimLight: dimLight,\n                        brightLight: brightLight\n                    });\n                    copy_item.data.attackBonus = (copy_item.data.attackBonus + bonus)\n                    targetActor.updateEmbeddedEntity(\"OwnedItem\", copy_item);\n                    target.update({\"dimLight\": 40, \"brightLight\": 20})\n                    \n                }\n            },\n            Cancel:\n            {\n                label: `Cancel`\n            }\n        }\n    }).render(true);\n}\n\nif (args[0] === \"off\") {\n    let flag = target.actor.getFlag('world', 'sacredWeapon')\n    let wpAttack = flag.weaponAttack\n    let itemId = flag.weapon\n    let item = target.actor.items.get(itemId);\n    let dimLight = flag.dimLight\n    let brightLight = flag.brightLight\n    let copy_item = duplicate(item);\n    copy_item.data.attackBonus = wpAttack;\n    targetActor.updateEmbeddedEntity(\"OwnedItem\", copy_item);\n    target.update({\"dimLight\": dimLight, \"brightLight\": brightLight})\n    target.actor.unsetFlag(`world`, `sacredWeapon`);\n}","author":"X2FU4EYTKyUpwF0o","img":"modules/GMmacros/player-img/Sacred-weapon.png","actorIds":[],"_id":"QAijZtZFCIrD7Yif"}
