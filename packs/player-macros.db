{"name":"Swap_token","type":"script","author":"Be8r6Sgxcs3sL08I","img":"modules/GMmacros/img/swap_token.png","scope":"global","command":"const tokens = canvas.tokens.controlled;\nif(tokens.length !== 2) return ui.notifications.warn('Please select exactly 2 tokens.');\n\nconst updates = [\n {_id: tokens[0].id, x: tokens[1].x, y: tokens[1].y},\n {_id: tokens[1].id, x: tokens[0].x, y: tokens[0].y}];\nawait canvas.scene.updateEmbeddedDocuments(\"Token\", updates);","flags":{"combat-utility-belt":{"macroTrigger":""},"advanced-macros":{"runAsGM":true,"runForEveryone":false,"runForSpecificUser":""},"macro-marker":{"activeData":{"icon":"icons/svg/dice-target.svg","tooltip":"New Macro","colour":"#ff0000","trigger":""}},"core":{"sourceId":"Macro.DmjzqVAL6mPck879"}},"ownership":{"default":0,"rbM5nB1AbUwbj4yJ":3,"Be8r6Sgxcs3sL08I":3},"_stats":{"systemId":"dnd5e","systemVersion":"2.0.3","coreVersion":"10.290","createdTime":1669768613214,"modifiedTime":1669768815403,"lastModifiedBy":"Be8r6Sgxcs3sL08I"},"folder":null,"sort":0,"_id":"0ZF5StyM0cBZL3D7"}
{"name":"Passar_turno","type":"script","author":"rbM5nB1AbUwbj4yJ","img":"modules/GMmacros/img/skip_turn.jpg","scope":"global","command":"/*\nAuthor: willisrocks\nDescription: \nEnds the current actors turn in a combat encounter. Useful when you don't pop out your combat tracker\nand want to end the turn from your hotbar.\nIf the user is a gamemaster, it will always end the current turn. For players, it will only end \nthe turn when the current actor in the turn order is owned by you. \nBased on the work of reddit user serrag97: https://www.reddit.com/r/FoundryVTT/comments/j1b8gs/next_turn_shortcut/\n*/\n\n// check if the user is a GM\nconst isGM = game.user.isGM;\n// check if the user owns the combatant whose turn it is\nconst isOwner = game.combat.combatant.isOwner;\n\nif (isGM || isOwner) {\n  game.combat.nextTurn();\n} else {\n  ui.notifications.info(\"As a player you can only advance your turn\");\n}","folder":null,"sort":0,"flags":{"combat-utility-belt":{"macroTrigger":""},"advanced-macros":{"runAsGM":false},"exportSource":{"world":"criador","system":"dnd5e","coreVersion":"0.8.8","systemVersion":"1.3.6"},"core":{"sourceId":"Macro.Us9ANKoXgfEYWFxz"}},"_id":"ABLx0o1RtltjLEoY","ownership":{"default":0,"rbM5nB1AbUwbj4yJ":3},"_stats":{"systemId":"dnd5e","systemVersion":"2.0.3","coreVersion":"10.290","createdTime":null,"modifiedTime":1668380922328,"lastModifiedBy":"Be8r6Sgxcs3sL08I"}}
{"name":"Draw-Shape-Sequencer","type":"script","scope":"global","author":"Be8r6Sgxcs3sL08I","img":"icons/svg/dice-target.svg","command":"new Sequence()\n    .effect()\n        .attachTo(token)\n        .persist()\n        .shape(\"circle\", {\n            lineSize: 4,\n            lineColor: \"#FF0000\",\n            radius: 1.5,\n            gridUnits: true,\n            name: \"test\"\n        })\n        .loopProperty(\"shapes.test\", \"scale.x\", { from: 0.9, to: 1.1, duration: 1000, pingPong: true, ease: \"easeInOutSine\" })\n        .loopProperty(\"shapes.test\", \"scale.y\", { from: 0.9, to: 1.1, duration: 1000, pingPong: true, ease: \"easeInOutSine\" })\n    .play()","ownership":{"default":0,"Be8r6Sgxcs3sL08I":3},"flags":{"advanced-macros":{"runAsGM":false,"runForEveryone":false,"runForSpecificUser":""},"core":{"sourceId":"Macro.Yxb15uAZuZaxgvSA"}},"_stats":{"systemId":"dnd5e","systemVersion":"2.0.3","coreVersion":"10.290","createdTime":1669826240566,"modifiedTime":1669826277536,"lastModifiedBy":"Be8r6Sgxcs3sL08I"},"folder":null,"sort":0,"_id":"GNYMzgXHEmnAAX5l"}
{"name":"Emissary_of_Redemption_2","type":"script","scope":"global","author":"Be8r6Sgxcs3sL08I","img":"icons/svg/dice-target.svg","command":"const version = \"10.0.33\"\nconst workfloww = MidiQOL.Workflow.getWorkflow(args[0].uuid)\nconst owner = workfloww.actor;\nif (!owner?.effects.find(i=>i.data.label === \"Emissary of Redemption Attacked\")) return;\n\nif (args[0].macroPass = \"isDamaged\") {\ntry {\n\tconst actor = args[0].options?.actor;\n\tconst token = args[0].options?.token;\n\tconst target = fromUuidSync(args[0].tokenUuid);\n\tconst workflow = args[0];\n\tlet danocausado = workflow.damageTotal;\n\tlet damageType = workflow.damageDetail\n\tconst reflete = Math.floor(danocausado+1) // arredonda para cima, pq a resistencia vai ser para baixo.\n\tconst damageRoll = await new Roll(`${reflete}`).roll({async: true});\n\tawait new MidiQOL.DamageOnlyWorkflow(actor, token, damageRoll.total, damageType, [token], damageRoll, {flavor: \"Vc causou dano em mim! Correção de dano aqui\",itemCardId: args[0].itemCardId});\n } catch (err) {\n   console.error(`Retribution ${version}`, err);\n }\n}","ownership":{"default":0,"Be8r6Sgxcs3sL08I":3},"flags":{"advanced-macros":{"runAsGM":true,"runForSpecificUser":""},"core":{"sourceId":"Macro.T16Rs86D08UNZUnF"}},"_stats":{"systemId":"dnd5e","systemVersion":"2.1.5","coreVersion":"10.291","createdTime":1686611738114,"modifiedTime":1686614084969,"lastModifiedBy":"Be8r6Sgxcs3sL08I"},"folder":null,"sort":0,"_id":"IBl7ceAFV9bbijZe"}
{"name":"Activate effect suspended","type":"script","scope":"global","author":"Be8r6Sgxcs3sL08I","img":"icons/svg/dice-target.svg","command":"const effect = actor.effects.find(e => e.data.label === \"Emissary of Redemption\");\nif(!effect.disabled) {\n    await effect.update({ disabled: true });\n} else {\nawait effect.update({ disabled: false });}","ownership":{"default":0,"Be8r6Sgxcs3sL08I":3},"flags":{"advanced-macros":{"runAsGM":false,"runForEveryone":false,"runForSpecificUser":""},"core":{"sourceId":"Macro.WgvsACwCs4kf6xZO"}},"_stats":{"systemId":"dnd5e","systemVersion":"2.0.3","coreVersion":"10.290","createdTime":1670004676757,"modifiedTime":1670007927726,"lastModifiedBy":"Be8r6Sgxcs3sL08I"},"folder":null,"sort":0,"_id":"SEjSi6K7SP7HRE4C"}
{"name":"Acoes_extras","type":"script","author":"Be8r6Sgxcs3sL08I","img":"modules/GMmacros/img/acoes_adicionais.png","scope":"global","command":"// pag 274\n\nnew Dialog({\n        title: \"Opções de ações extras\",\n        content: \"<p>Selecione a ação</p>\",\n        buttons: {\n            one: {\n                label: ` <img class=\"button-image\" src=\"modules/dfreds-convenient-effects/images/grappled.svg\", style=\"width: 40px; height: 40px\">Agarrar (Grapple)`,\n                callback: async () => {\n(async()=>{\n\n//inicio code\nconst attacker = token; //selected token\nconst target = game.user.targets.first(); //targeted creature\nconst uuid = game.user.targets.first().actor.uuid;\nconst hasEffectApplied = game.dfreds.effectInterface.hasEffectApplied('Grappled', uuid);\nconst immunity = target.actor.system.traits.ci.value.has(\"grappled\");\n\nif(immunity === true) {\n  ui.notifications.info(\"Immune to Grapple!\");\n  return;\n}\n\nconst skilltoberolled = target.actor.system.skills.ath.total < target.actor.system.skills.acr.total ? \"acr\" : \"ath\";\n\nresults = await game.MonksTokenBar.requestContestedRoll({\n    token:attacker,\n    request: 'skill:ath'\n},{\n    token: target,\n    request:`skill:${skilltoberolled}`\n},{\n    silent:true, \n    fastForward:false,\n    flavor: `${attacker.name} tries to grapple ${target.name}.`, \n});\n\nlet i=0;\nwhile (results.flags['monks-tokenbar'][`token${attacker.id}`].passed === \"waiting\" && i < 30) {\n    await new Promise(resolve => setTimeout(resolve, 500))\n    i++;\n}\nif (results.flags[\"monks-tokenbar\"][`token${attacker.id}`].passed === \"won\") {\n    success = \"Agarrou com Sucesso: \";\n    let the_message = `${attacker.name} <span style=\"color: blue\"><b> ${success}</b> </span> ${target.name}.`;\n    ChatMessage.create({\n    user: game.user._id,\n    speaker: ChatMessage.getSpeaker({actor: attacker}),\n    content: the_message,\n});\nif (!hasEffectApplied) {\n    await game.dfreds.effectInterface.addEffect({ effectName: 'Grappled', uuid});\n }\n} else {\n    success = \"Falhou o Agarrão em\";\n    let the_message = `${attacker.name} <span style=\"color: red\"><b> ${success}</b> </span> ${target.name}.`;\n    ChatMessage.create({\n    user: game.user._id,\n    speaker: ChatMessage.getSpeaker({actor: attacker}),\n    content: the_message,\n});\n} // fim code\n\n})();\n\n                       } // fim async content\n                 }, // fim agarrar\n            nine: {\n                label: ` <img class=\"button-image\" src=\"modules/dfreds-convenient-effects/images/prone.svg\", style=\"width: 40px; height: 40px\">Derrubar (Shove) (Prone)` ,\n                callback: async () => {\n(async()=>{\n\n//inicio code\nconst attacker = token; //selected token\nconst target = game.user.targets.first(); //targeted creature\nconst uuid = game.user.targets.first().actor.uuid;\nconst hasEffectApplied = game.dfreds.effectInterface.hasEffectApplied('Prone', uuid);\nconst immunity = target.actor.system.traits.ci.value.has(\"prone\");\n\nif(immunity === true) {\n  ui.notifications.info(\"Immune to Prone!\");\n  return;\n}\n\nconst skilltoberolled = target.actor.system.skills.ath.total < target.actor.system.skills.acr.total ? \"acr\" : \"ath\";\n\nresults = await game.MonksTokenBar.requestContestedRoll({\n    token:attacker,\n    request: 'skill:ath'\n},{\n    token: target,\n    request:`skill:${skilltoberolled}`\n},{\n    silent:true, \n    fastForward:false,\n    flavor: `${attacker.name} tenta derrubar Prone: ${target.name}.`, \n});\n\nlet i=0;\nwhile (results.flags['monks-tokenbar'][`token${attacker.id}`].passed === \"waiting\" && i < 30) {\n    await new Promise(resolve => setTimeout(resolve, 500))\n    i++;\n}\nif (results.flags[\"monks-tokenbar\"][`token${attacker.id}`].passed === \"won\") {\n    success = \"Derrubou com Sucesso: \";\n    let the_message = `${attacker.name} <span style=\"color: blue\"><b> ${success}</b> </span> ${target.name}.`;\n    ChatMessage.create({\n    user: game.user._id,\n    speaker: ChatMessage.getSpeaker({actor: attacker}),\n    content: the_message,\n});\nif (!hasEffectApplied) {\n    await game.dfreds.effectInterface.addEffect({ effectName: 'Prone', uuid});\n }\n} else {\n    success = \"Falhou em Derrubar\";\n    let the_message = `${attacker.name} <span style=\"color: red\"><b> ${success}</b> </span> ${target.name}.`;\n    ChatMessage.create({\n    user: game.user._id,\n    speaker: ChatMessage.getSpeaker({actor: attacker}),\n    content: the_message,\n});\n} // fim code\n\n\n})();\n\n                       } // fim async content\n                 }, // fim empurrão prone\n\n            seven: {\n                label: \" 🤜 Empurar 5ft (Shove)\",\n                callback: async () => {\n(async()=>{\n\n\n//inicio code\nconst attacker = token; //selected token\nconst target = game.user.targets.first(); //targeted creature\nconst uuid = game.user.targets.first().actor.uuid;\n\nconst skilltoberolled = target.actor.system.skills.ath.total < target.actor.system.skills.acr.total ? \"acr\" : \"ath\";\n\nresults = await game.MonksTokenBar.requestContestedRoll({\n    token:attacker,\n    request: 'skill:ath'\n},{\n    token: target,\n    request:`skill:${skilltoberolled}`\n},{\n    silent:true, \n    fastForward:false,\n    flavor: `${attacker.name} tenta empurrar 5ft: ${target.name}.`, \n});\n\nlet i=0;\nwhile (results.flags['monks-tokenbar'][`token${attacker.id}`].passed === \"waiting\" && i < 30) {\n    await new Promise(resolve => setTimeout(resolve, 500))\n    i++;\n}\nif (results.flags[\"monks-tokenbar\"][`token${attacker.id}`].passed === \"won\") {\n    success = \"empurrou com Sucesso: \";\n    let the_message = `${attacker.name} <span style=\"color: blue\"><b> ${success}</b> </span> ${target.name}. Mova o token.`;\n    ChatMessage.create({\n    user: game.user._id,\n    speaker: ChatMessage.getSpeaker({actor: attacker}),\n    content: the_message,\n});\n} else {\n    success = \"Falhou em empurrar\";\n    let the_message = `${attacker.name} <span style=\"color: red\"><b> ${success}</b> </span> ${target.name}.`;\n    ChatMessage.create({\n    user: game.user._id,\n    speaker: ChatMessage.getSpeaker({actor: attacker}),\n    content: the_message,\n});\n} // fim code\n\n\n})();\n\n                       } // fim async content\n                 }, // fim empurrão\n\n            six: {\n                label: \"🛡️ Esquiva (Dodge)\",\n                callback: async () => {\nconst uuid = canvas.tokens.controlled[0].actor.uuid;\nconst hasEffectApplied = await game.dfreds.effectInterface.hasEffectApplied('Dodge', uuid);\n\nif (!hasEffectApplied) {\n  game.dfreds.effectInterface.addEffect({ effectName: 'Dodge', uuid });\n} else {\n  game.dfreds.effectInterface.removeEffect({ effectName: 'Dodge', uuid });}\n                       } \n            }, // fim dodge\n            two: {\n                label: \"⚔️ Desarmar (limitado)\",\n                callback: async () => {\n(async()=>{\n\nChatMessage.create({content: \"Uma criatura pode usar um ataque com arma para derrubar uma arma ou outro objeto das mãos de um alvo. O atacante faz uma jogada de ataque contestada pelo teste de Força (Atletismo) ou Destreza (Acrobacia) do alvo. Se o atacante vencer a disputa, o ataque não causa dano ou qualquer outro efeito negativo, mas o atacado deixa o objeto cair no chão. O atacante tem desvantagem em sua jogada de ataque se o alvo estiver segurando o objeto com duas ou mais mãos. O alvo tem vantagem em seu teste de atributo se for maior que a criatura atacante, ou desvantagem se for menor\"});\n\n(async()=>{/**\n * Grab a list of tools in the selected player's inventory, then all the user to make a roll on the tool.\n * Will take into consideration if the player is proficient in using the tool.\n */\n\n// get the first entry from the array of currently selected tokens. Works best/exclusively with one selected token\nconst target = canvas.tokens.controlled[0].actor;\n// get the abilities of the selected token for ease of access later\nconst { abilities } = target.data.data;\n// Only items set as \"tools\" will be included!\n// get all held and equipped Tools/Kits/Supplies. Might want to replace with /[tT]ools|[kK]it|[sS]upplies|[sS]et$/ if gaming sets should be included\nlet toolsInInventory = target.items.filter(i=>i.type === \"weapon\");\n// const toolProficiencies = target.data.data.traits.toolProf; // Tools have proficiency mod in the object under <item>.data.data.proficient. \nlet tool = undefined;\n\n// Choose ability mod dialog\nconst abilityDialog = (async () => {\n    let template = `\n    <div>\n        <div class=\"form-group\">\n            <label>Choose ability</label>\n            <select id=\"selectedAbility\">`\n    for (let ability in abilities) {\n        switch (ability) {\n            case \"str\":\n                abilities[ability].name = \"Strength\"\n                break;\n            case \"dex\":\n                abilities[ability].name = \"Dexterity\"\n                break;\n            case \"con\":\n                abilities[ability].name = \"Constitution\"\n                break;\n            case \"int\":\n                abilities[ability].name = \"Intelligence\"\n                break;\n            case \"wis\":\n                abilities[ability].name = \"Wisdom\"\n                break;\n            case \"cha\":\n                abilities[ability].name = \"Charisma\"\n                break;\n            default:\n                console.log(\"something went wrong\");\n        }\n        template += `<option value=\"${ability}\">${abilities[ability].name} (${abilities[ability].value})</option>`;\n    }\n    template += `</select>\n        </div>\n    </div>`\n\n\n    new Dialog({\n        title: tool.name,\n        content: template,\n        buttons: {\n            ok: {\n                icon: '<i class=\"fas fa-check\"></i>',\n                label: \"OK\",\n                callback: async (html) => {\n                    const selection = html.find(\"#selectedAbility\")[0].value;\n                    console.log(tool, target);\n                    let prof = tool.data.data.proficient * target.data.data.attributes.prof; // target might be half or doubly proficient. This will make sure it is accounted for\n                    let bonusattack = tool.data.data.attackBonus\n\t\t    let typeac = tool.data.data.actionType\n\t\t    const globalbonus = tool.data.data.actionType == \"mwak\" ? target.data.data.bonuses.mwak.attack : target.data.data.bonuses.rwak.attack\n                    let messageContent = `${target.name} Rolou Dado 1: <b>[[1d20+${abilities[selection].mod}+${prof}+${bonusattack}+${globalbonus}]]</b> e Dado 2: <b>[[1d20+${abilities[selection].mod}+${prof}+${bonusattack}+${globalbonus}]]</b> para a ação  de desarmar com ${tool.name}. Utilize dado 1 caso não tenha vantagem nem desvantgem. [[1d20+${abilities[selection].mod}(${abilities[selection].name})+${prof}(Proficiency)+${bonusattack}(Bonus Arma)+${globalbonus}(Bonus global)]]</b><br>`;\n                    let chatData = {\n                        user: game.user.id,\n                        speaker: ChatMessage.getSpeaker(),\n                        content: messageContent,\n                        // uncomment the line below to always whisper the roll to the GM\n                        // whisper: game.users.entities.filter(u => u.isGM).map(u => u._id)\n                    };\n                    ChatMessage.create(chatData, {});\n               }\n            },\n            cancel: {\n                icon: '<i class=\"fas fa-times\"></i>',\n                label: 'Cancel'\n            }\n        },\n        default: \"cancel\"\n    }).render(true);\n})\n\n// Choose tool dialog\nif (toolsInInventory.length) {\n    (async () => {\n        let template = `\n        <div>\n            <div class=\"form-group\">\n                <label>Choose a tool</label>\n                <select id=\"selectedTool\">`\n        toolsInInventory.forEach( tempTool => {    \n            template += `<option value=\"${tempTool.name}\">${tempTool.name}</option>`;\n        });\n        template += `</select>\n            </div>\n        </div>`;\n\n        new Dialog({\n            title: 'Which tool?',\n            content: template,\n            buttons: {\n                ok: {\n                    icon: '<i class=\"fas fa-check\"></i>',\n                    label: \"OK\",\n                    callback: async (html) => {\n                        let selection = html.find(\"#selectedTool\")[0].value;\n                        tool = toolsInInventory.find( item => item.name === selection )\n                        abilityDialog();\n                   }\n                },\n                cancel: {\n                    icon: '<i class=\"fas fa-times\"></i>',\n                    label: 'Cancel'\n                }\n            },\n            default: \"cancel\"\n        }).render(true);\n    })()    \n}\n\nelse {\t\n    new Dialog({\n        title: 'No Tools!',\n        content: '<p>You don\\'t seem to have any tool with you.</p>',\n        buttons: {\n            ok: {\n                icon: '<i class=\"fas fa-check\"></i>',\n                label: \"OK\"\n            }\n        },\n        default: \"ok\"\n    }).render(true);\n}}) ()\n\n// check which has a better modifier\nconst attacker = token; //selected token\nconst target = game.user.targets.first(); //targeted creature\nconst uuid = game.user.targets.first().actor.uuid;\nconst skilltoberolled = target.actor.system.skills.ath.total < target.actor.system.skills.acr.total ? \"acr\" : \"ath\";\nconst targets = Array.from(game.user.targets);\nawait game.MonksTokenBar.requestRoll(targets,{request:`skill:${ skilltoberolled}`, silent: true});\n\n\n})()\n                 } }, // two\n            four: {\n                label: \"Escalar (Climb)\",\n                callback: async () => {\n(async()=>{\n\n\n//inicio code\nconst attacker = token; //selected token\nconst skilltoberolled = attacker.actor.system.skills.ath.total < attacker.actor.system.skills.acr.total ? \"acr\" : \"ath\";\nconst target = game.user.targets.first(); //targeted creature\nconst uuid = game.user.targets.first().actor.uuid;\nresults = await game.MonksTokenBar.requestContestedRoll({\n    token:attacker,\n    request:`skill:${skilltoberolled}`\n},{\n    token: target,\n    request: 'skill:acr'\n},{\n    silent:true, \n    fastForward:false,\n    flavor: `${attacker.name} tenta escalar ${target.name}.`, \n});\n\nlet i=0;\nwhile (results.flags['monks-tokenbar'][`token${attacker.id}`].passed === \"waiting\" && i < 30) {\n    await new Promise(resolve => setTimeout(resolve, 500))\n    i++;\n}\nif (results.flags[\"monks-tokenbar\"][`token${attacker.id}`].passed === \"won\") {\n    success = \"Escalou com Sucesso: \";\n    let the_message = `${attacker.name} <span style=\"color: blue\"><b> ${success}</b> </span> ${target.name}.`;\n    ChatMessage.create({\n    user: game.user._id,\n    speaker: ChatMessage.getSpeaker({actor: attacker}),\n    content: the_message,\n});\n} else {\n    success = \"Falhou em Escalar\";\n    let the_message = `${attacker.name} <span style=\"color: red\"><b> ${success}</b> </span> ${target.name}.`;\n    ChatMessage.create({\n    user: game.user._id,\n    speaker: ChatMessage.getSpeaker({actor: attacker}),\n    content: the_message,\n});\n} // fim code\n\n})();\n                       }\n                 }, ////// fim escalar\n            three: {\n                label: \"Atropelar (Overrun)\",\n                callback: async () => {\n(async()=>{\n\n\n//inicio code\nconst attacker = token; //selected token\nconst target = game.user.targets.first(); //targeted creature\n\nresults = await game.MonksTokenBar.requestContestedRoll({\n    token:attacker,\n    request: 'skill:ath'\n},{\n    token: target,\n    request: 'skill:ath'\n},{\n    silent:true, \n    fastForward:false,\n    flavor: `${attacker.name} tenta passar pelo espaço de ${target.name}.`, \n});\n\nlet i=0;\nwhile (results.flags['monks-tokenbar'][`token${attacker.id}`].passed === \"waiting\" && i < 30) {\n    await new Promise(resolve => setTimeout(resolve, 500))\n    i++;\n}\nif (results.flags[\"monks-tokenbar\"][`token${attacker.id}`].passed === \"won\") {\n    success = \"Atropelou com Sucesso: \";\n    let the_message = `${attacker.name} <span style=\"color: blue\"><b> ${success}</b> </span> ${target.name}. Você pode passar 1 vez pelo espaço do alvo.`;\n    ChatMessage.create({\n    user: game.user._id,\n    speaker: ChatMessage.getSpeaker({actor: attacker}),\n    content: the_message,\n});\n} else {\n    success = \"Falhou em Escalar\";\n    let the_message = `${attacker.name} <span style=\"color: red\"><b> ${success}</b> </span> ${target.name}.`;\n    ChatMessage.create({\n    user: game.user._id,\n    speaker: ChatMessage.getSpeaker({actor: attacker}),\n    content: the_message,\n});\n} // fim code\n\n})();\n                       } \n            }, // fim atropelar\n\n            five: {\n                label: \"Cambalhota (Tumble)\",\n                callback: async () => {\n(async()=>{\n\n\n//inicio code\nconst attacker = token; //selected token\nconst target = game.user.targets.first(); //targeted creature\n\nresults = await game.MonksTokenBar.requestContestedRoll({\n    token:attacker,\n    request: 'skill:acr'\n},{\n    token: target,\n    request: 'skill:acr'\n},{\n    silent:true, \n    fastForward:false,\n    flavor: `${attacker.name} tenta passar pelo espaço de ${target.name}.`, \n});\n\nlet i=0;\nwhile (results.flags['monks-tokenbar'][`token${attacker.id}`].passed === \"waiting\" && i < 30) {\n    await new Promise(resolve => setTimeout(resolve, 500))\n    i++;\n}\nif (results.flags[\"monks-tokenbar\"][`token${attacker.id}`].passed === \"won\") {\n    success = \"Passou com Sucesso por: \";\n    let the_message = `${attacker.name} <span style=\"color: blue\"><b> ${success}</b> </span> ${target.name}. Você pode passar 1 vez pelo espaço do alvo.`;\n    ChatMessage.create({\n    user: game.user._id,\n    speaker: ChatMessage.getSpeaker({actor: attacker}),\n    content: the_message,\n});\n} else {\n    success = \"Falhou em Passar por:\";\n    let the_message = `${attacker.name} <span style=\"color: red\"><b> ${success}</b> </span> ${target.name}.`;\n    ChatMessage.create({\n    user: game.user._id,\n    speaker: ChatMessage.getSpeaker({actor: attacker}),\n    content: the_message,\n});\n} // fim code\n\n\n\n})();\n                       } \n            }, // fim cambalhota\n\n           eight: {\n                label: \"Escapar agarrão (Grapple)\",\n                callback: async () => {\n(async()=>{\n\n//inicio code\nconst attacker = token; //selected token\nconst target = game.user.targets.first(); //targeted creature\nconst uuid = game.user.targets.first().actor.uuid;\nconst meuuid = canvas.tokens.controlled[0].actor.uuid;\nconst skilltoberolled = attacker.actor.system.skills.ath.total < attacker.actor.system.skills.acr.total ? \"acr\" : \"ath\";\n\nresults = await game.MonksTokenBar.requestContestedRoll({\n    token:attacker,\n    request:`skill:${skilltoberolled}`\n},{\n    token: target,\n    request: 'skill:ath'\n},{\n    silent:true, \n    fastForward:false,\n    flavor: `${attacker.name} tenta escapar do agarrão de ${target.name}.`, \n});\n\nlet i=0;\nwhile (results.flags['monks-tokenbar'][`token${attacker.id}`].passed === \"waiting\" && i < 30) {\n    await new Promise(resolve => setTimeout(resolve, 500))\n    i++;\n}\nif (results.flags[\"monks-tokenbar\"][`token${attacker.id}`].passed === \"won\") {\n\n    let targetEffect = actor.effects.find(eff => eff.label === 'Grappled');\n    MidiQOL.socket().executeAsGM(\"removeEffects\", {'actorUuid': meuuid, effects: [targetEffect.id]});\n\n    //await game.dfreds.effectInterface.removeEffect({ effectName: 'Grappled', meuuid});\n    success = \"Escapou com Sucesso: \";\n    let the_message = `${attacker.name} <span style=\"color: blue\"><b> ${success}</b> </span> ${target.name}.`;\n    ChatMessage.create({\n    user: game.user._id,\n    speaker: ChatMessage.getSpeaker({actor: attacker}),\n    content: the_message,\n});\n} else {\n    success = \"Falhou em escapar do agarrão de\";\n    let the_message = `${attacker.name} <span style=\"color: red\"><b> ${success}</b> </span> ${target.name}.`;\n    ChatMessage.create({\n    user: game.user._id,\n    speaker: ChatMessage.getSpeaker({actor: attacker}),\n    content: the_message,\n});\n} // fim code\n\n\n})();\n\n                       } // fim async content\n                 }, // fim escapar\n\n\n} }).render(true);//fim função","flags":{"combat-utility-belt":{"macroTrigger":""},"advanced-macros":{"runAsGM":false,"runForSpecificUser":""},"exportSource":{"world":"criador","system":"dnd5e","coreVersion":"0.8.8","systemVersion":"1.3.6"},"macro-marker":{"activeData":{"icon":"modules/GMmacros/img/acoes_adicionais.png","tooltip":"Ações_extras"}},"core":{"sourceId":"Macro.biIFauGQz2Xs9pkZ"}},"ownership":{"default":3,"QwT9izJ4aW8QVTjo":3,"Be8r6Sgxcs3sL08I":3},"_stats":{"systemId":"dnd5e","systemVersion":"2.2.1","coreVersion":"10.291","createdTime":1668381000745,"modifiedTime":1688584457646,"lastModifiedBy":"Be8r6Sgxcs3sL08I"},"folder":null,"sort":0,"_id":"VNX79QsUqZyxAJhQ"}
{"name":"Emissary_of_Redemption_1","type":"script","scope":"global","author":"Be8r6Sgxcs3sL08I","img":"icons/svg/dice-target.svg","command":"const workflow = MidiQOL.Workflow.getWorkflow(args[0].uuid); \nif (args[0].hitTargetUuids.length === 0) return {}\nconst tactor = (Array.from(workflow.targets))[0]?.actor; \nif (tactor?.effects.find(i=>i.data.label === \"Emissary of Redemption Attacked\")) {return} else {\n\tlet bsEffect = new ActiveEffect({label: \"Emissary of Redemption Attacked\", \n\t\t\t\t icon: \"modules/GMmacros/img/Emissary_redemption.png\"});\n\tfor (let tokenUuid of args[0].hitTargetUuids) {\n        \tconst target = await fromUuid(tokenUuid);\n        \tconst targetActor = target.actor;\n       \t\tif (!targetActor) continue;\n\t\tawait MidiQOL.socket().executeAsGM(\"createEffects\", {actorUuid: targetActor.uuid, effects: [bsEffect.toObject()]})\n }\n}","ownership":{"default":0,"Be8r6Sgxcs3sL08I":3},"flags":{"advanced-macros":{"runAsGM":true,"runForSpecificUser":""},"core":{"sourceId":"Macro.HWPAGjNnWkvDoTi1"}},"_stats":{"systemId":"dnd5e","systemVersion":"2.1.5","coreVersion":"10.291","createdTime":1686595886014,"modifiedTime":1686614353920,"lastModifiedBy":"Be8r6Sgxcs3sL08I"},"folder":null,"sort":0,"_id":"VnLNDtVNgVsKuHS3"}
{"$$deleted":true,"_id":"VNX79QsUqZyxAJhQ"}
{"name":"Acoes_extras","type":"script","author":"Be8r6Sgxcs3sL08I","img":"modules/GMmacros/img/acoes_adicionais.png","scope":"global","command":"// pag 274 DMG\n\n\n\n\n\nnew Dialog({\n        title: \"Opções de ações extras // 🎯 = marque um alvo\",\n        content: \"<p>Selecione a ação - </p>\",\n        render:(html)=>{\n         $(html[2]).css({'flex-direction':'column'})\n         html[0].remove()\n        },\n        buttons: {\n\n            six: {\n                label: `<img class=\"button-image\" src=\"modules/dfreds-convenient-effects/images/dodging.svg\", style=\"width: 30px; height: 30px\">   Esquiva (Dodge) - Action`,\n                callback: async () => {\nconst uuid = canvas.tokens.controlled[0].actor.uuid;\nconst hasEffectApplied = await game.dfreds.effectInterface.hasEffectApplied('Dodge', uuid);\n\nif (!hasEffectApplied) {\n  game.dfreds.effectInterface.addEffect({ effectName: 'Dodge', uuid });\n} else {\n  game.dfreds.effectInterface.removeEffect({ effectName: 'Dodge', uuid });}\n                       } \n            }, // fim dodge\n\n            one: {\n                label: ` <img class=\"button-image\" src=\"modules/GMmacros/img/grappled.png\", style=\"width: 30px; height: 30px\">   Agarrar (Grapple) - Action 🎯`,\n                callback: async () => {\n(async()=>{\n\n//inicio code\nconst attacker = token; //selected token\nconst target = game.user.targets.first(); //targeted creature\nconst uuid = game.user.targets.first().actor.uuid;\nconst hasEffectApplied = game.dfreds.effectInterface.hasEffectApplied('Grappled', uuid);\nconst immunity = target.actor.system.traits.ci.value.has(\"grappled\");\n\nif(immunity === true) {\n  ui.notifications.info(\"Immune to Grapple!\");\n  return;\n}\n\nconst skilltoberolled = target.actor.system.skills.ath.total < target.actor.system.skills.acr.total ? \"acr\" : \"ath\";\n\nresults = await game.MonksTokenBar.requestContestedRoll({\n    token:attacker,\n    request: 'skill:ath'\n},{\n    token: target,\n    request:`skill:${skilltoberolled}`\n},{\n    silent:true, \n    fastForward:false,\n    flavor: `${attacker.name} tries to grapple ${target.name}.`, \n});\n\nlet i=0;\nwhile (results.flags['monks-tokenbar'][`token${attacker.id}`].passed === \"waiting\" && i < 30) {\n    await new Promise(resolve => setTimeout(resolve, 900))\n    i++;\n}\nif (results.flags[\"monks-tokenbar\"][`token${attacker.id}`].passed === \"won\") {\n    success = \"Agarrou com Sucesso: \";\n    let the_message = `${attacker.name} <span style=\"color: blue\"><b> ${success}</b> </span> ${target.name}.`;\n    ChatMessage.create({\n    user: game.user._id,\n    speaker: ChatMessage.getSpeaker({actor: attacker}),\n    content: the_message,\n});\nif (!hasEffectApplied) {\n    await game.dfreds.effectInterface.addEffect({ effectName: 'Grappled', uuid});\n }\n} else {\n    success = \"Falhou o Agarrão em\";\n    let the_message = `${attacker.name} <span style=\"color: red\"><b> ${success}</b> </span> ${target.name}.`;\n    ChatMessage.create({\n    user: game.user._id,\n    speaker: ChatMessage.getSpeaker({actor: attacker}),\n    content: the_message,\n});\n} // fim code\n\n})();\n\n                       } // fim async content\n                 }, // fim agarrar\n\n           eight: {\n                label: `<img class=\"button-image\" src=\"icons/svg/padlock.svg\", style=\"width: 30px; height: 30px\">   Escapar agarrão (Grapple) - Action 🎯`,\n                callback: async () => {\n(async()=>{\n\n//inicio code\nconst attacker = token; //selected token\nconst target = game.user.targets.first(); //targeted creature\nconst uuid = game.user.targets.first().actor.uuid;\nconst meuuid = canvas.tokens.controlled[0].actor.uuid;\nconst skilltoberolled = attacker.actor.system.skills.ath.total < attacker.actor.system.skills.acr.total ? \"acr\" : \"ath\";\n\nresults = await game.MonksTokenBar.requestContestedRoll({\n    token:attacker,\n    request:`skill:${skilltoberolled}`\n},{\n    token: target,\n    request: 'skill:ath'\n},{\n    silent:true, \n    fastForward:false,\n    flavor: `${attacker.name} tenta escapar do agarrão de ${target.name}.`, \n});\n\nlet i=0;\nwhile (results.flags['monks-tokenbar'][`token${attacker.id}`].passed === \"waiting\" && i < 30) {\n    await new Promise(resolve => setTimeout(resolve, 900))\n    i++;\n}\nif (results.flags[\"monks-tokenbar\"][`token${attacker.id}`].passed === \"won\") {\n\n    let targetEffect = actor.effects.find(eff => eff.label === 'Grappled');\n    MidiQOL.socket().executeAsGM(\"removeEffects\", {'actorUuid': meuuid, effects: [targetEffect.id]});\n\n    //await game.dfreds.effectInterface.removeEffect({ effectName: 'Grappled', meuuid});\n    success = \"Escapou com Sucesso: \";\n    let the_message = `${attacker.name} <span style=\"color: blue\"><b> ${success}</b> </span> ${target.name}.`;\n    ChatMessage.create({\n    user: game.user._id,\n    speaker: ChatMessage.getSpeaker({actor: attacker}),\n    content: the_message,\n});\n} else {\n    success = \"Falhou em escapar do agarrão de\";\n    let the_message = `${attacker.name} <span style=\"color: red\"><b> ${success}</b> </span> ${target.name}.`;\n    ChatMessage.create({\n    user: game.user._id,\n    speaker: ChatMessage.getSpeaker({actor: attacker}),\n    content: the_message,\n});\n} // fim code\n\n\n})();\n\n                       } // fim async content\n                 }, // fim escapar\n\n            nine: {\n                label: ` <img class=\"button-image\" src=\"modules/dfreds-convenient-effects/images/prone.svg\", style=\"width: 30px; height: 30px\">   Derrubar (Shove) (Prone) - Action 🎯` ,\n                callback: async () => {\n(async()=>{\n\n//inicio code\nconst attacker = token; //selected token\nconst target = game.user.targets.first(); //targeted creature\nconst uuid = game.user.targets.first().actor.uuid;\nconst hasEffectApplied = game.dfreds.effectInterface.hasEffectApplied('Prone', uuid);\nconst immunity = target.actor.system.traits.ci.value.has(\"prone\");\n\nif(immunity === true) {\n  ui.notifications.info(\"Immune to Prone!\");\n  return;\n}\n\nconst skilltoberolled = target.actor.system.skills.ath.total < target.actor.system.skills.acr.total ? \"acr\" : \"ath\";\n\nresults = await game.MonksTokenBar.requestContestedRoll({\n    token:attacker,\n    request: 'skill:ath'\n},{\n    token: target,\n    request:`skill:${skilltoberolled}`\n},{\n    silent:true, \n    fastForward:false,\n    flavor: `${attacker.name} tenta derrubar Prone: ${target.name}.`, \n});\n\nlet i=0;\nwhile (results.flags['monks-tokenbar'][`token${attacker.id}`].passed === \"waiting\" && i < 30) {\n    await new Promise(resolve => setTimeout(resolve, 900))\n    i++;\n}\nif (results.flags[\"monks-tokenbar\"][`token${attacker.id}`].passed === \"won\") {\n    success = \"Derrubou com Sucesso: \";\n    let the_message = `${attacker.name} <span style=\"color: blue\"><b> ${success}</b> </span> ${target.name}.`;\n    ChatMessage.create({\n    user: game.user._id,\n    speaker: ChatMessage.getSpeaker({actor: attacker}),\n    content: the_message,\n});\nif (!hasEffectApplied) {\n    await game.dfreds.effectInterface.addEffect({ effectName: 'Prone', uuid});\n }\n} else {\n    success = \"Falhou em Derrubar\";\n    let the_message = `${attacker.name} <span style=\"color: red\"><b> ${success}</b> </span> ${target.name}.`;\n    ChatMessage.create({\n    user: game.user._id,\n    speaker: ChatMessage.getSpeaker({actor: attacker}),\n    content: the_message,\n});\n} // fim code\n\n\n})();\n\n                       } // fim async content\n                 }, // fim empurrão prone\n\n            seven: {\n                label: \" 🤜 Empurar 5ft (Shove) - Action 🎯\",\n                callback: async () => {\n(async()=>{\n\n\n//inicio code\nconst attacker = token; //selected token\nconst target = game.user.targets.first(); //targeted creature\nconst uuid = game.user.targets.first().actor.uuid;\n\nconst skilltoberolled = target.actor.system.skills.ath.total < target.actor.system.skills.acr.total ? \"acr\" : \"ath\";\n\nresults = await game.MonksTokenBar.requestContestedRoll({\n    token:attacker,\n    request: 'skill:ath'\n},{\n    token: target,\n    request:`skill:${skilltoberolled}`\n},{\n    silent:true, \n    fastForward:false,\n    flavor: `${attacker.name} tenta empurrar 5ft: ${target.name}.`, \n});\n\nlet i=0;\nwhile (results.flags['monks-tokenbar'][`token${attacker.id}`].passed === \"waiting\" && i < 30) {\n    await new Promise(resolve => setTimeout(resolve, 900))\n    i++;\n}\nif (results.flags[\"monks-tokenbar\"][`token${attacker.id}`].passed === \"won\") {\n    success = \"empurrou com Sucesso: \";\n    let the_message = `${attacker.name} <span style=\"color: blue\"><b> ${success}</b> </span> ${target.name}. Mova o token.`;\n    ChatMessage.create({\n    user: game.user._id,\n    speaker: ChatMessage.getSpeaker({actor: attacker}),\n    content: the_message,\n});\n} else {\n    success = \"Falhou em empurrar\";\n    let the_message = `${attacker.name} <span style=\"color: red\"><b> ${success}</b> </span> ${target.name}.`;\n    ChatMessage.create({\n    user: game.user._id,\n    speaker: ChatMessage.getSpeaker({actor: attacker}),\n    content: the_message,\n});\n} // fim code\n\n\n})();\n\n                       } // fim async content\n                 }, // fim empurrão\n\n\n\n\n\n\n\n            four: {\n                label: \"Escalar (Climb) - Action 🎯\",\n                callback: async () => {\n(async()=>{\n\n\n//inicio code\nconst attacker = token; //selected token\nconst skilltoberolled = attacker.actor.system.skills.ath.total < attacker.actor.system.skills.acr.total ? \"acr\" : \"ath\";\nconst target = game.user.targets.first(); //targeted creature\nconst uuid = game.user.targets.first().actor.uuid;\nresults = await game.MonksTokenBar.requestContestedRoll({\n    token:attacker,\n    request:`skill:${skilltoberolled}`\n},{\n    token: target,\n    request: 'skill:acr'\n},{\n    silent:true, \n    fastForward:false,\n    flavor: `${attacker.name} tenta escalar ${target.name}.`, \n});\n\nlet i=0;\nwhile (results.flags['monks-tokenbar'][`token${attacker.id}`].passed === \"waiting\" && i < 30) {\n    await new Promise(resolve => setTimeout(resolve, 900))\n    i++;\n}\nif (results.flags[\"monks-tokenbar\"][`token${attacker.id}`].passed === \"won\") {\n    success = \"Escalou com Sucesso: \";\n    let the_message = `${attacker.name} <span style=\"color: blue\"><b> ${success}</b> </span> ${target.name}.`;\n    ChatMessage.create({\n    user: game.user._id,\n    speaker: ChatMessage.getSpeaker({actor: attacker}),\n    content: the_message,\n});\n} else {\n    success = \"Falhou em Escalar\";\n    let the_message = `${attacker.name} <span style=\"color: red\"><b> ${success}</b> </span> ${target.name}.`;\n    ChatMessage.create({\n    user: game.user._id,\n    speaker: ChatMessage.getSpeaker({actor: attacker}),\n    content: the_message,\n});\n} // fim code\n\n})();\n                       }\n                 }, ////// fim escalar\n            three: {\n                label: \"Atropelar (Overrun) - Action or Bonus action  🎯\",\n                callback: async () => {\n(async()=>{\n\n\n//inicio code\nconst attacker = token; //selected token\nconst target = game.user.targets.first(); //targeted creature\n\nresults = await game.MonksTokenBar.requestContestedRoll({\n    token:attacker,\n    request: 'skill:ath'\n},{\n    token: target,\n    request: 'skill:ath'\n},{\n    silent:true, \n    fastForward:false,\n    flavor: `${attacker.name} tenta passar pelo espaço de ${target.name}.`, \n});\n\nlet i=0;\nwhile (results.flags['monks-tokenbar'][`token${attacker.id}`].passed === \"waiting\" && i < 30) {\n    await new Promise(resolve => setTimeout(resolve, 900))\n    i++;\n}\nif (results.flags[\"monks-tokenbar\"][`token${attacker.id}`].passed === \"won\") {\n    success = \"Atropelou com Sucesso: \";\n    let the_message = `${attacker.name} <span style=\"color: blue\"><b> ${success}</b> </span> ${target.name}. Você pode passar 1 vez pelo espaço do alvo.`;\n    ChatMessage.create({\n    user: game.user._id,\n    speaker: ChatMessage.getSpeaker({actor: attacker}),\n    content: the_message,\n});\n} else {\n    success = \"Falhou em Escalar\";\n    let the_message = `${attacker.name} <span style=\"color: red\"><b> ${success}</b> </span> ${target.name}.`;\n    ChatMessage.create({\n    user: game.user._id,\n    speaker: ChatMessage.getSpeaker({actor: attacker}),\n    content: the_message,\n});\n} // fim code\n\n})();\n                       } \n            }, // fim atropelar\n\n\n            five: {\n                label: \"Cambalhota (Tumble) - Action or Bonus action 🎯\",\n                callback: async () => {\n(async()=>{\n\n\n//inicio code\nconst attacker = token; //selected token\nconst target = game.user.targets.first(); //targeted creature\n\nresults = await game.MonksTokenBar.requestContestedRoll({\n    token:attacker,\n    request: 'skill:acr'\n},{\n    token: target,\n    request: 'skill:acr'\n},{\n    silent:true, \n    fastForward:false,\n    flavor: `${attacker.name} tenta passar pelo espaço de ${target.name}.`, \n});\n\nlet i=0;\nwhile (results.flags['monks-tokenbar'][`token${attacker.id}`].passed === \"waiting\" && i < 30) {\n    await new Promise(resolve => setTimeout(resolve, 900))\n    i++;\n}\nif (results.flags[\"monks-tokenbar\"][`token${attacker.id}`].passed === \"won\") {\n    success = \"Passou com Sucesso por: \";\n    let the_message = `${attacker.name} <span style=\"color: blue\"><b> ${success}</b> </span> ${target.name}. Você pode passar 1 vez pelo espaço do alvo.`;\n    ChatMessage.create({\n    user: game.user._id,\n    speaker: ChatMessage.getSpeaker({actor: attacker}),\n    content: the_message,\n});\n} else {\n    success = \"Falhou em Passar por:\";\n    let the_message = `${attacker.name} <span style=\"color: red\"><b> ${success}</b> </span> ${target.name}.`;\n    ChatMessage.create({\n    user: game.user._id,\n    speaker: ChatMessage.getSpeaker({actor: attacker}),\n    content: the_message,\n});\n} // fim code\n\n\n\n})();\n                       } \n            }, // fim cambalhota\n\n\n            two: {\n                label: \"⚔️ Desarmar (limitado) - Action  🎯\",\n                callback: async () => {\n(async()=>{\n\nChatMessage.create({content: \"Uma criatura pode usar um ataque com arma para derrubar uma arma ou outro objeto das mãos de um alvo. O atacante faz uma jogada de ataque contestada pelo teste de Força (Atletismo) ou Destreza (Acrobacia) do alvo. Se o atacante vencer a disputa, o ataque não causa dano ou qualquer outro efeito negativo, mas o atacado deixa o objeto cair no chão. O atacante tem desvantagem em sua jogada de ataque se o alvo estiver segurando o objeto com duas ou mais mãos. O alvo tem vantagem em seu teste de atributo se for maior que a criatura atacante, ou desvantagem se for menor\"});\n\n(async()=>{/**\n * Grab a list of tools in the selected player's inventory, then all the user to make a roll on the tool.\n * Will take into consideration if the player is proficient in using the tool.\n */\n\n// get the first entry from the array of currently selected tokens. Works best/exclusively with one selected token\nconst target = canvas.tokens.controlled[0].actor;\n// get the abilities of the selected token for ease of access later\nconst { abilities } = target.data.data;\n// Only items set as \"tools\" will be included!\n// get all held and equipped Tools/Kits/Supplies. Might want to replace with /[tT]ools|[kK]it|[sS]upplies|[sS]et$/ if gaming sets should be included\nlet toolsInInventory = target.items.filter(i=>i.type === \"weapon\");\n// const toolProficiencies = target.data.data.traits.toolProf; // Tools have proficiency mod in the object under <item>.data.data.proficient. \nlet tool = undefined;\n\n// Choose ability mod dialog\nconst abilityDialog = (async () => {\n    let template = `\n    <div>\n        <div class=\"form-group\">\n            <label>Choose ability</label>\n            <select id=\"selectedAbility\">`\n    for (let ability in abilities) {\n        switch (ability) {\n            case \"str\":\n                abilities[ability].name = \"Strength\"\n                break;\n            case \"dex\":\n                abilities[ability].name = \"Dexterity\"\n                break;\n            case \"con\":\n                abilities[ability].name = \"Constitution\"\n                break;\n            case \"int\":\n                abilities[ability].name = \"Intelligence\"\n                break;\n            case \"wis\":\n                abilities[ability].name = \"Wisdom\"\n                break;\n            case \"cha\":\n                abilities[ability].name = \"Charisma\"\n                break;\n            default:\n                console.log(\"something went wrong\");\n        }\n        template += `<option value=\"${ability}\">${abilities[ability].name} (${abilities[ability].value})</option>`;\n    }\n    template += `</select>\n        </div>\n    </div>`\n\n\n    new Dialog({\n        title: tool.name,\n        content: template,\n        buttons: {\n            ok: {\n                icon: '<i class=\"fas fa-check\"></i>',\n                label: \"OK\",\n                callback: async (html) => {\n                    const selection = html.find(\"#selectedAbility\")[0].value;\n                    console.log(tool, target);\n                    let prof = tool.data.data.proficient * target.data.data.attributes.prof; // target might be half or doubly proficient. This will make sure it is accounted for\n                    let bonusattack = tool.data.data.attackBonus\n\t\t    let typeac = tool.data.data.actionType\n\t\t    const globalbonus = tool.data.data.actionType == \"mwak\" ? target.data.data.bonuses.mwak.attack : target.data.data.bonuses.rwak.attack\n                    let messageContent = `${target.name} Rolou Dado 1: <b>[[1d20+${abilities[selection].mod}+${prof}+${bonusattack}+${globalbonus}]]</b> e Dado 2: <b>[[1d20+${abilities[selection].mod}+${prof}+${bonusattack}+${globalbonus}]]</b> para a ação  de desarmar com ${tool.name}. Utilize dado 1 caso não tenha vantagem nem desvantgem. [[1d20+${abilities[selection].mod}(${abilities[selection].name})+${prof}(Proficiency)+${bonusattack}(Bonus Arma)+${globalbonus}(Bonus global)]]</b><br>`;\n                    let chatData = {\n                        user: game.user.id,\n                        speaker: ChatMessage.getSpeaker(),\n                        content: messageContent,\n                        // uncomment the line below to always whisper the roll to the GM\n                        // whisper: game.users.entities.filter(u => u.isGM).map(u => u._id)\n                    };\n                    ChatMessage.create(chatData, {});\n               }\n            },\n            cancel: {\n                icon: '<i class=\"fas fa-times\"></i>',\n                label: 'Cancel'\n            }\n        },\n        default: \"cancel\"\n    }).render(true);\n})\n\n// Choose tool dialog\nif (toolsInInventory.length) {\n    (async () => {\n        let template = `\n        <div>\n            <div class=\"form-group\">\n                <label>Choose a tool</label>\n                <select id=\"selectedTool\">`\n        toolsInInventory.forEach( tempTool => {    \n            template += `<option value=\"${tempTool.name}\">${tempTool.name}</option>`;\n        });\n        template += `</select>\n            </div>\n        </div>`;\n\n        new Dialog({\n            title: 'Which tool?',\n            content: template,\n            buttons: {\n                ok: {\n                    icon: '<i class=\"fas fa-check\"></i>',\n                    label: \"OK\",\n                    callback: async (html) => {\n                        let selection = html.find(\"#selectedTool\")[0].value;\n                        tool = toolsInInventory.find( item => item.name === selection )\n                        abilityDialog();\n                   }\n                },\n                cancel: {\n                    icon: '<i class=\"fas fa-times\"></i>',\n                    label: 'Cancel'\n                }\n            },\n            default: \"cancel\"\n        }).render(true);\n    })()    \n}\n\nelse {\t\n    new Dialog({\n        title: 'No Tools!',\n        content: '<p>You don\\'t seem to have any tool with you.</p>',\n        buttons: {\n            ok: {\n                icon: '<i class=\"fas fa-check\"></i>',\n                label: \"OK\"\n            }\n        },\n        default: \"ok\"\n    }).render(true);\n}}) ()\n\n// check which has a better modifier\nconst attacker = token; //selected token\nconst target = game.user.targets.first(); //targeted creature\nconst uuid = game.user.targets.first().actor.uuid;\nconst skilltoberolled = target.actor.system.skills.ath.total < target.actor.system.skills.acr.total ? \"acr\" : \"ath\";\nconst targets = Array.from(game.user.targets);\nawait game.MonksTokenBar.requestRoll(targets,{request:`skill:${ skilltoberolled}`, silent: true});\n\n\n})()\n                 } }, // two\n\n\n} }).render(true);//fim função","flags":{"combat-utility-belt":{"macroTrigger":""},"advanced-macros":{"runAsGM":false,"runForSpecificUser":""},"exportSource":{"world":"criador","system":"dnd5e","coreVersion":"0.8.8","systemVersion":"1.3.6"},"macro-marker":{"activeData":{"icon":"modules/GMmacros/img/acoes_adicionais.png","tooltip":"Ações_extras"}},"core":{"sourceId":"Macro.biIFauGQz2Xs9pkZ"}},"ownership":{"default":3,"QwT9izJ4aW8QVTjo":3,"Be8r6Sgxcs3sL08I":3},"_stats":{"systemId":"dnd5e","systemVersion":"2.2.1","coreVersion":"10.291","createdTime":1668381000745,"modifiedTime":1688602052420,"lastModifiedBy":"Be8r6Sgxcs3sL08I"},"folder":null,"sort":0,"_id":"AOJprYmCqobIubHm"}
